\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % aggiunto per caratteri accentati
\usepackage{geometry}
\geometry{margin=3cm}
\usepackage{tikz}
\usepackage{listings}
\usepackage{xcolor} % per colori opzionali
\usepackage{multicol} % per ambiente multicols
\usepackage{hyperref} % per i link e il comando \url

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{blue!10},   % sfondo blu chiaro
    frame=single,                      % bordo attorno al codice
    language=Python,                   % evidenziazione Python
    basicstyle=\ttfamily\small,       % font monospace
    keywordstyle=\color{blue},        % parole chiave blu
    commentstyle=\color{green!60!black}, % commenti in verde
    stringstyle=\color{orange},       % stringhe arancioni
    showstringspaces=false            % non mostra spazi nelle stringhe
}

\lstset{style=mystyle}


\begin{document}

% Pagina iniziale
\begin{titlepage}
    \centering
    \vspace*{5cm}
    {\Huge\bfseries Guida Base di Python\par}
    \vfill
    \begin{flushright}
        \large Angelo Vaccaro
    \end{flushright}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduzione}
Python è un linguaggio di programmazione ad alto livello,
interpretato e orientato agli oggetti. È noto per la sua sintassi
semplice e leggibile, che lo rende ideale per i principianti.
\newpage
\section{Sintassi}
Questo codice chiede all'utente di inserire un messaggio e poi lo stampa.
\begin{lstlisting}
    messaggio = input("Inserisci un messaggio: ")
    print(messaggio)
\end{lstlisting}
\vspace{1em}
I commenti in Python iniziano con il simbolo \# e continuano fino alla fine della riga.
Non esistono i commenti multilinea come in altri linguaggi.
\begin{lstlisting}
    #Commento
\end{lstlisting}
\vspace{1em}
L'indentazione è fondamentale in Python e serve a definire i blocchi di codice. In python a differenza di altri linguaggi se ci saranno errori di indentazione te lo farà notare, non ci saranno più punti e virgole bensì il codice sarà definito dall'indentazione.
\begin{lstlisting}
    if True:
        print("Questo e' vero")
    else:
        print("Questo non e' vero")
\end{lstlisting}
\vspace{1em}
\newpage

\section{Variabili}
Una variabile è un nome che rappresenta un valore. In Python non è necessario dichiarare il tipo di variabile, poiché il linguaggio è dinamicamente tipizzato.
Python a differenza di altri linguaggi non ha bisogno di dichiarare il tipo di variabile, ma lo fa in automatico.
\begin{lstlisting}
    x = 5
    y = "Ciao"
    z = 3.14
\end{lstlisting}
\vspace{1em}
Una parte fondamentale delle variabili è la nomenclatura, che deve essere chiara e significativa. Alcuni nomi di variabili non sono permessi, come ad esempio:
\begin{lstlisting}
    1x = 5 # non e' permesso
    x-y = 10 # non e' permesso
    x y = 15 # non e' permesso
\end{lstlisting}
E ci sono molti altri nomi di variabili che non sono permessi, come ad esempio:
\begin{itemize}
    \item and
    \item as
    \item assert
    \item break
    \item class
    \item continue
    \item def
    \item del
    \item elif
    \item else
    \item except
    \item False
    \item finally
    \item for
    \item from
    \item global
    \item if
    \item import
    \item in
    \item is
    \item lambda
    \item None
    \item nonlocal
    \item not
    \item or
    \item pass
    \item raise
    \item return
    \item True
    \item try
    \item while
    \item with
    \item yield
\end{itemize}
Attenzione perché in Python le variabili sono case-sensitive, quindi \texttt{variabile} e \texttt{Variabile} sono due variabili diverse.
Per scrivere variabili possiamo usare diversi case:
\begin{itemize}
    \item \textbf{snake\_case}: \texttt{variabile\_esempio}
    \item \textbf{camelCase}: \texttt{variabileEsempio}
    \item \textbf{PascalCase}: \texttt{VariabileEsempio}
\end{itemize}
Quello suggerito è lo \textbf{snake\_case}, che è il più usato in Python.\\
Assegnamo multipli valori a più variabili in una sola riga:
\begin{lstlisting}
    x, y, z = 1, 2, 3
    print(x) # 1
    print(y) # 2
    print(z) # 3
\end{lstlisting}
\vspace{1em}
Possiamo avere anche multipli valori in una sola variabile:
\begin{lstlisting}
    x = y = z = 1
    print(x) # 1
    print(y) # 1
    print(z) # 1
\end{lstlisting}
\vspace{1em}
Possiamo fare anche l'unpacking di una collezione:
\begin{lstlisting}
    x = [1, 2, 3]
    a, b, c = x
    print(a) # 1
    print(b) # 2
    print(c) # 3
\end{lstlisting}
Così facendo abbiamo tutti i valori salvati in una variabile, e poi li possiamo assegnare a più variabili.
\vspace{1em}
\newpage

\section{Tipi di dati}
I tipi di dati in Python sono:
\begin{itemize}
    \item \textbf{int}: numeri interi (es. 1, -5, 100)
    \item \textbf{float}: numeri decimali (es. 3.14, -0.001)
    \item \textbf{complex}: numeri complessi (es. 2+3j)
    \item \textbf{bool}: valori booleani (\texttt{True}, \texttt{False})
    \item \textbf{str}: stringhe di testo (es. "ciao", 'Python')
    \item \textbf{list}: liste ordinate e modificabili (es. [1, 2, 3])
    \item \textbf{tuple}: tuple ordinate e immutabili (es. (1, 2, 3))
    \item \textbf{range}: intervalli di numeri (es. range(5))
    \item \textbf{dict}: dizionari (coppie chiave-valore) (es. \{"a": 1, "b": 2\})
    \item \textbf{set}: insiemi non ordinati e senza duplicati (es. \{1, 2, 3\})
    \item \textbf{frozenset}: insiemi immutabili (es. frozenset([1, 2, 3]))
    \item \textbf{bytes}: sequenze immutabili di byte (es. b"ciao")
    \item \textbf{bytearray}: sequenze mutabili di byte (es. bytearray(5))
    \item \textbf{memoryview}: viste su dati binari (es. memoryview(b"ciao"))
    \item \textbf{NoneType}: tipo speciale per il valore \texttt{None}
\end{itemize}
\vspace{1em}
La funzione per scoprire il tipo di una variabile è \texttt{type()}:
\begin{lstlisting}
    x = 5
    print(type(x)) # <class 'int'>

    y = 3.14
    print(type(y)) # <class 'float'>

    z = "Ciao"
    print(type(z)) # <class 'str'>

    a = [1, 2, 3]
    print(type(a)) # <class 'list'> equivalente a list()
    #che sarebbe una lista

    b = (1, 2, 3)
    print(type(b)) # <class 'tuple'> equivalente a tuple()
    #che sarebbe una tupla

    c = {1, 2, 3}
    print(type(c)) # <class 'set'>  equivalente a set()
    #che sarebbe un insieme

    d = {"a": 1, "b": 2}
    print(type(d)) # <class 'dict'> equivalente a dict()
    #che sarebbe un dizionario

    x= range(5)
    print(type(x)) # <class 'range'> equivalente a range()
    #che sarebbe un range

    x= True
    print(type(x)) # <class 'bool'> equivalente a bool()
    #che sarebbe un booleano
\end{lstlisting}
In python il tipo di dato viene assegnato in automatico, quindi non è necessario dichiararlo esplicitamente.
\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{ATTENZIONE QUINDI ALL'UTILIZZO DELLE VARIABILI E DEI LORO TIPI!}
        }
    }
\end{center}
\newpage

\section{Casting}
Castare significa convertire un tipo di dato in un altro.
Ad esempio, possiamo convertire un numero intero in una stringa:
\begin{lstlisting}
    x = 5
    y = str(x) # ora y e' una stringa "5"
    print(y) # "5"
    print(type(y)) # <class 'str'>
\end{lstlisting}
Possiamo anche convertire una stringa in un numero intero:
\begin{lstlisting}
    x = "10"
    y = int(x) # ora y e' un intero 10
    print(y) # 10
    print(type(y)) # <class 'int'>
\end{lstlisting}
Quando si fa? Lo facciamo quando vogliamo convertire un tipo di dato in un altro, ad esempio quando vogliamo sommare due numeri e uno è una stringa.
\begin{lstlisting}
    x = "10"
    y = 5
    z = int(x) + y # ora z e' un intero 15
    print(z) # 15
    print(type(z)) # <class 'int'>
\end{lstlisting}
\newpage

\section{Stringhe}
Le stringhe in Python sono sequenze di caratteri racchiuse tra virgolette singole o doppie.
Possiamo usare le virgolette singole o doppie per definire una stringa:
\begin{lstlisting}
    stringa1 = "Ciao"
    stringa2 = 'Mondo'
\end{lstlisting}
Possiamo anche usare le triple virgolette per definire stringhe multilinea:
\begin{lstlisting}
    stringa_multilinea = """Questa e' una stringa
    che si estende su piu' righe."""
    print(stringa_multilinea)
    # Output:
    # Questa e' una stringa
    # che si estende su piu' righe.
\end{lstlisting}
\vspace{1em}
Le stringhe sono una collezione di caratteri, quindi possiamo accedere a un singolo carattere usando l'indice:
\begin{lstlisting}
    stringa = "Ciao"
    print(stringa[0]) # C
    print(stringa[1]) # i
    print(stringa[2]) # a
    print(stringa[3]) # o
    print(stringa[-1]) # o
\end{lstlisting}
Anche lo spazio è considerato un carattere, quindi se scriviamo:
\begin{lstlisting}
    stringa = "Ciao Mondo"
    print(stringa[9]) # spazio
\end{lstlisting}
\vspace{1em}
La funzione per definire la lunghezza di una stringa è \texttt{len()}:
\begin{lstlisting}
    stringa = "Ciao"
    print(len(stringa)) # 4
\end{lstlisting}
\vspace{1em}
Se utilizziamo l'operatore \texttt{:} possiamo accedere a una parte della stringa, ad esempio:
\begin{lstlisting}
    stringa = "Ciao Mondo"
    print(stringa[0:4]) # Ciao
    print(stringa[5:10]) # Mondo
    print(stringa[:4]) # Ciao
    print(stringa[5:]) # Mondo
    print(stringa[:]) # Ciao Mondo
    print(stringa[-5:]) # Mondo
    print(stringa[-5:-1]) # Mond
\end{lstlisting}
\vspace{1em}
Possiamo modificare una stringa utilizzando dei metodi, ad esempio:
\begin{lstlisting}
    stringa = "Ciao Mondo"
    print(stringa.upper()) # CIAO MONDO

    print(stringa.lower()) # ciao mondo

    print(stringa.title()) # Ciao Mondo

    print(stringa.capitalize()) # Ciao mondo

    print(stringa.strip()) # Ciao Mondo (rimuove gli spazi)

    print(stringa.replace("Ciao", "Salve")) # Salve Mondo

    print(stringa.split()) # ['Ciao', 'Mondo']
    #(divide la stringa in una lista)

    print(stringa.split(" ")) # ['Ciao', 'Mondo']
    #(divide la stringa in una lista)

    print(stringa.split("o")) # ['Ciao M', 'nd']
    #(divide la stringa in una lista)
\end{lstlisting}
\vspace{1em}
La concatenazione delle stringhe avviene con l'operatore \texttt{+}:
\begin{lstlisting}
    stringa1 = "Ciao"
    stringa2 = "Mondo"
    stringa3 = stringa1 + " " + stringa2
    print(stringa3) # Ciao Mondo
    print(stringa1 + stringa2) # CiaoMondo
    print(stringa1 + " " + stringa2) # Ciao Mondo
\end{lstlisting}
Ci viene in aiuto anche l'operatore \texttt{.format()} per formattare le stringhe:
\begin{lstlisting}
nome = "Mario"
eta = 30
stringa ="Ciao, mi chiamo {} e ho {} anni.".format(nome, eta)
print(stringa) # Ciao, mi chiamo Mario e ho 30 anni.
stringa ="Ciao, mi chiamo {0} e ho {1} anni.".format(nome,eta)
print(stringa) # Ciao, mi chiamo Mario e ho 30 anni.
\end{lstlisting}
\vspace{1em}
L'escape dei caratteri è un modo per inserire caratteri speciali in una stringa. Ad esempio, per inserire un apice singolo o doppio all'interno di una stringa, possiamo usare il backslash \texttt{\textbackslash}:
\begin{lstlisting}
stringa = 'Ciao, mi chiamo \'Mario\' e ho 30 anni.'
print(stringa) # Ciao, mi chiamo 'Mario' e ho 30 anni.

stringa = "Ciao, mi chiamo \"Mario\" e ho 30 anni."
print(stringa) # Ciao, mi chiamo "Mario" e ho 30 anni.

stringa ="Ciao, mi chiamo \"Mario\" e ho 30 anni.\nCome stai?"
print(stringa) # Ciao, mi chiamo "Mario" e ho 30 anni.
               # Come stai?
\end{lstlisting}
\vspace{1em}
\section{booleani}
I booleani in Python sono un tipo di dato che può assumere solo due valori: \texttt{True} (vero) e \texttt{False} (falso). Sono molto usati nelle condizioni, nei cicli e nei confronti.

\begin{lstlisting}
vero = True
falso = False
print(type(vero))   # <class 'bool'>
print(type(falso))  # <class 'bool'>
\end{lstlisting}

\subsection*{Operatori di confronto}
Gli operatori di confronto restituiscono un valore booleano:
\begin{lstlisting}
print(5 > 3)   # True
print(2 == 4)  # False
print(7 != 8)  # True
print(10 >= 10) # True
print(3 < 1)   # False
\end{lstlisting}

\subsection*{Operatori logici}
Gli operatori logici permettono di combinare più condizioni:
\begin{itemize}
    \item \texttt{and}: restituisce \texttt{True} solo se entrambe le condizioni sono vere
    \item \texttt{or}: restituisce \texttt{True} se almeno una delle condizioni è vera
    \item \texttt{not}: inverte il valore booleano
\end{itemize}
\begin{lstlisting}
a = True
b = False
print(a and b) # False
print(a or b)  # True
print(not a)   # False
\end{lstlisting}

\subsection*{Valori considerati falsi}
In Python, alcuni valori sono considerati automaticamente \texttt{False} in un contesto booleano:
\begin{itemize}
    \item \texttt{0}, \texttt{0.0}
    \item \texttt{''} (stringa vuota)
    \item \texttt{[]} (lista vuota)
    \item \texttt{()} (tupla vuota)
    \item \texttt{\{\}} (dizionario vuoto)
    \item \texttt{set()} (insieme vuoto)
    \item \texttt{None}
\end{itemize}
Tutti gli altri valori sono considerati \texttt{True}.

\begin{lstlisting}
print(bool(0))        # False
print(bool(""))       # False
print(bool([]))       # False
print(bool(None))     # False
print(bool(123))      # True
print(bool("Python")) # True
\end{lstlisting}

\subsection*{Uso dei booleani nelle condizioni}
I booleani sono fondamentali nelle istruzioni \texttt{if}, \texttt{while} e in tutte le strutture di controllo:
\begin{lstlisting}
x = 10
if x > 5:
    print("x e' maggiore di 5")
else:
    print("x non e' maggiore di 5")
\end{lstlisting}

\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{RICORDA:} In Python la prima lettera di \texttt{True} e \texttt{False} è maiuscola!
        }
    }
\end{center}

\section{Operazioni Aritmetiche}
Le operazioni aritmetiche in Python permettono di eseguire calcoli tra numeri. Python supporta tutti gli operatori aritmetici di base, oltre ad alcune operazioni avanzate.

\subsection*{Operatori aritmetici di base}
\begin{itemize}
    \item \texttt{+} \textbf{(addizione)}: somma due valori.
    \item \texttt{-} \textbf{(sottrazione)}: sottrae il secondo valore dal primo.
    \item \texttt{*} \textbf{(moltiplicazione)}: moltiplica due valori.
    \item \texttt{/} \textbf{(divisione)}: divide il primo valore per il secondo (risultato \texttt{float}).
    \item \texttt{//} \textbf{(divisione intera)}: divide e restituisce solo la parte intera del risultato.
    \item \texttt{\%} \textbf{(modulo)}: restituisce il resto della divisione.
    \item \texttt{**} \textbf{(potenza)}: eleva il primo valore alla potenza del secondo.
\end{itemize}

\begin{lstlisting}
a = 10
b = 3
print(a + b)   # 13
print(a - b)   # 7
print(a * b)   # 30
print(a / b)   # 3.333...
print(a // b)  # 3
print(a % b)   # 1
print(a ** b)  # 1000
\end{lstlisting}

\subsection*{Precedenza degli operatori}
Gli operatori aritmetici seguono le regole di precedenza matematica:
\begin{enumerate}
    \item Parentesi \texttt{()}
    \item Potenza \texttt{**}
    \item Moltiplicazione, divisione, divisione intera, modulo \texttt{* / // \%}
    \item Addizione e sottrazione \texttt{+ -}
\end{enumerate}
Puoi usare le parentesi per forzare l'ordine di esecuzione:
\begin{lstlisting}
print(2 + 3 * 4)      # 14
print((2 + 3) * 4)    # 20
print(2 ** 3 ** 2)    # 512 (equivale a 2 ** (3 ** 2))
\end{lstlisting}

\subsection*{Assegnamento con operatore}
Puoi combinare l'assegnamento con un'operazione aritmetica:
\begin{lstlisting}
x = 5
x += 2   # x = x + 2 -> 7
x -= 1   # x = x - 1 -> 6
x *= 3   # x = x * 3 -> 18
x /= 2   # x = x / 2 -> 9.0
x //= 2  # x = x // 2 -> 4.0
x %= 3   # x = x % 3 -> 1.0
x **= 4  # x = x ** 4 -> 1.0
\end{lstlisting}

\subsection*{Divisione tra interi e float}
Se uno degli operandi è un \texttt{float}, il risultato sarà un \texttt{float}:
\begin{lstlisting}
print(5 / 2)    # 2.5
print(5 // 2)   # 2
print(5.0 / 2)  # 2.5
print(5.0 // 2) # 2.0
\end{lstlisting}

\subsection*{Operazioni con numeri negativi}
Attenzione al comportamento di divisione intera e modulo con numeri negativi:
\begin{lstlisting}
print(-7 // 3)  # -3
print(-7 % 3)   # 2
print(7 // -3)  # -3
print(7 % -3)   # -2
\end{lstlisting}
La divisione intera arrotonda sempre verso il basso (floor division).

\subsection*{Funzioni matematiche utili}
Python include la libreria \texttt{math} per operazioni avanzate:
\begin{lstlisting}
import math
print(math.sqrt(16))    # 4.0 (radice quadrata)
print(math.pow(2, 5))   # 32.0 (potenza)
print(math.ceil(2.3))   # 3 (arrotonda per eccesso)
print(math.floor(2.7))  # 2 (arrotonda per difetto)
print(math.fabs(-5))    # 5.0 (valore assoluto)
print(math.factorial(5))# 120 (fattoriale)
print(math.pi)          # 3.141592...
print(math.e)           # 2.718281...
\end{lstlisting}

\subsection*{Arrotondamenti}
La funzione \texttt{round()} arrotonda un numero al numero di decimali desiderato:
\begin{lstlisting}
print(round(3.14159, 2)) # 3.14
print(round(2.718, 0))   # 3.0
\end{lstlisting}

\subsection*{Conversione tra tipi numerici}
Puoi convertire tra \texttt{int}, \texttt{float} e \texttt{complex}:
\begin{lstlisting}
x = 5
y = float(x)     # 5.0
z = int(3.7)     # 3
c = complex(2,3) # (2+3j)
\end{lstlisting}

\subsection*{Numeri complessi}
Python supporta i numeri complessi nativamente:
\begin{lstlisting}
c1 = 2 + 3j
c2 = 1 - 4j
print(c1 + c2)   # (3-1j)
print(c1 * c2)   # (14-5j)
print(c1.real)   # 2.0 (parte reale)
print(c1.imag)   # 3.0 (parte immaginaria)
\end{lstlisting}

\subsection*{Operatori unari}
\begin{itemize}
    \item \texttt{+x}: restituisce il valore di \texttt{x}
    \item \texttt{-x}: restituisce l'opposto di \texttt{x}
\end{itemize}
\begin{lstlisting}
x = 5
print(+x)  # 5
print(-x)  # -5
\end{lstlisting}

\subsection*{Funzione \texttt{abs()}}
Restituisce il valore assoluto di un numero:
\begin{lstlisting}
print(abs(-10))  # 10
print(abs(3.5))  # 3.5
\end{lstlisting}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Calcolo dell'area di un cerchio
raggio = 5
area = math.pi * (raggio ** 2)
print(area)  # 78.53981633974483

# Calcolo della media di tre numeri
a, b, c = 4, 7, 10
media = (a + b + c) / 3
print(media) # 7.0
\end{lstlisting}

\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{RICORDA:} In Python la divisione \texttt{/} restituisce sempre un \texttt{float}, anche se i numeri sono interi!
        }
    }
\end{center}

\section{Condizioni con if, elif, else}
Le istruzioni \texttt{if}, \texttt{elif} ed \texttt{else} permettono di eseguire blocchi di codice in base a condizioni booleane. Sono fondamentali per il controllo del flusso nei programmi Python.

\subsection*{Struttura base}

La sintassi di base è la seguente:
\begin{lstlisting}
if condizione:
    # blocco eseguito se la condizione e' vera
elif altra\_condizione:
    # blocco eseguito se la prima condizione e' falsa e
    #questa e' vera
else:
    # blocco eseguito se tutte le condizioni precedenti
    #sono false
\end{lstlisting}

\textbf{Nota:} L'indentazione è obbligatoria in Python per delimitare i blocchi di codice.

\subsection*{Esempio semplice}

\begin{lstlisting}
x = 10
if x > 0:
    print("x e' positivo")
elif x == 0:
    print("x e' zero")
else:
    print("x e' negativo")
\end{lstlisting}

\subsection*{Più condizioni con \texttt{elif}}

Puoi usare quanti \texttt{elif} vuoi:
\begin{lstlisting}
voto = 85
if voto >= 90:
    print("Ottimo")
elif voto >= 70:
    print("Buono")
elif voto >= 60:
    print("Sufficiente")
else:
    print("Insufficiente")
\end{lstlisting}

\subsection*{Condizioni annidate (nested if)}

Puoi inserire un \texttt{if} dentro un altro \texttt{if}:
\begin{lstlisting}
x = 5
if x > 0:
    print("Positivo")
    if x % 2 == 0:
        print("Pari")
    else:
        print("Dispari")
else:
    print("Non positivo")
\end{lstlisting}

\subsection*{Operatori di confronto e logici}

Le condizioni possono usare operatori di confronto (\texttt{==}, \texttt{!=}, \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=}) e operatori logici (\texttt{and}, \texttt{or}, \texttt{not}):
\begin{lstlisting}
eta = 20
patente = True
if eta >= 18 and patente:
    print("Puoi guidare")
else:
    print("Non puoi guidare")
\end{lstlisting}

\subsection*{Condizioni su valori "falsy"}

Qualsiasi valore che è "falsy" (come \texttt{0}, \texttt{""}, \texttt{[]}, \texttt{None}) è considerato \texttt{False} in una condizione:
\begin{lstlisting}
nome = ""
if nome:
    print("Hai inserito un nome")
else:
    print("Nome mancante")
\end{lstlisting}

\subsection*{Condizione su più righe}

Puoi scrivere condizioni lunghe su più righe usando la barra inversa \textbackslash:
\begin{lstlisting}
x = 5
y = 10
if x > 0 and \
   y > 0:
    print("Entrambi positivi")
\end{lstlisting}

\subsection*{Istruzione \texttt{pass}}

Se vuoi lasciare vuoto un blocco \texttt{if}, usa \texttt{pass}:
\begin{lstlisting}
if x > 0:
    pass  # da implementare in futuro
else:
    print("x non e' positivo")
\end{lstlisting}

\subsection*{Istruzione \texttt{if} su una sola riga}

Per condizioni semplici puoi scrivere tutto su una riga:
\begin{lstlisting}
if x > 0: print("Positivo")
\end{lstlisting}

\subsection*{Operatore ternario (if in una riga)}

Per assegnare un valore in base a una condizione:
\begin{lstlisting}
messaggio = "Maggiore di 10" if x > 10 else
"Minore o uguale a 10"
print(messaggio)
\end{lstlisting}

\subsection*{Esempio pratico}

\begin{lstlisting}
numero = int(input("Inserisci un numero: "))
if numero % 2 == 0:
    print("Il numero e' pari")
else:
    print("Il numero e' dispari")
\end{lstlisting}

\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{RICORDA:} In Python l'indentazione è fondamentale per il corretto funzionamento delle condizioni!
        }
    }
\end{center}

\section{Cicli While}
Il ciclo \texttt{while} in Python permette di eseguire ripetutamente un blocco di codice finché una condizione booleana è vera. È uno degli strumenti fondamentali per la programmazione iterativa.

\subsection*{Sintassi di base}
La struttura di un ciclo \texttt{while} è la seguente:
\begin{lstlisting}
while condizione:
    # blocco di istruzioni da ripetere
\end{lstlisting}
Il blocco di codice viene eseguito finché la \texttt{condizione} è vera (\texttt{True}). Appena la condizione diventa falsa (\texttt{False}), il ciclo termina e l'esecuzione prosegue dopo il ciclo.

\subsection*{Esempio semplice}
\begin{lstlisting}
contatore = 0
while contatore < 5:
    print("Contatore:", contatore)
    contatore += 1
# Output:
# Contatore: 0
# Contatore: 1
# Contatore: 2
# Contatore: 3
# Contatore: 4
\end{lstlisting}

\subsection*{Funzionamento dettagliato}
\begin{itemize}
    \item La condizione viene valutata \textbf{prima} di ogni iterazione.
    \item Se la condizione è \texttt{True}, il blocco viene eseguito.
    \item Alla fine del blocco, la condizione viene rivalutata.
    \item Se la condizione è \texttt{False}, il ciclo termina.
\end{itemize}

\subsection*{Ciclo potenzialmente infinito}
Se la condizione non diventa mai falsa, il ciclo \texttt{while} continua all'infinito (loop infinito):
\begin{lstlisting}
while True:
    print("Questo ciclo non termina mai!")
\end{lstlisting}
Per interrompere manualmente un ciclo infinito, si può usare la combinazione di tasti \texttt{Ctrl+C} nel terminale.

\subsection*{Uso della variabile di controllo}
Spesso si utilizza una variabile di controllo che viene aggiornata all'interno del ciclo per evitare loop infiniti:
\begin{lstlisting}
x = 10
while x > 0:
    print(x)
    x -= 1
\end{lstlisting}

\subsection*{Istruzione \texttt{break}}
L'istruzione \texttt{break} permette di uscire immediatamente dal ciclo, anche se la condizione è ancora vera:
\begin{lstlisting}
while True:
    risposta = input("Scrivi 'esci' per terminare: ")
    if risposta == "esci":
        break
    print("Hai scritto:", risposta)
\end{lstlisting}

\subsection*{Istruzione \texttt{continue}}
L'istruzione \texttt{continue} interrompe l'iterazione corrente e passa subito alla valutazione della condizione per la prossima iterazione:
\begin{lstlisting}
i = 0
while i < 10:
    i += 1
    if i % 2 == 0:
        continue
    print(i)  # stampa solo i numeri dispari da 1 a 9
\end{lstlisting}

\subsection*{Istruzione \texttt{else} con while}
Il ciclo \texttt{while} può avere una clausola \texttt{else}, che viene eseguita solo se il ciclo termina normalmente (cioè non tramite \texttt{break}):
\begin{lstlisting}
x = 3
while x > 0:
    print(x)
    x -= 1
else:
    print("Ciclo terminato normalmente")
\end{lstlisting}
Se il ciclo viene interrotto con \texttt{break}, il blocco \texttt{else} non viene eseguito:
\begin{lstlisting}
x = 3
while x > 0:
    print(x)
    if x == 2:
        break
    x -= 1
else:
    print("Questo non viene stampato")
\end{lstlisting}

\subsection*{Esempio: input fino a condizione}
\begin{lstlisting}
password = ""
while password != "python":
    password = input("Inserisci la password: ")
print("Accesso consentito!")
\end{lstlisting}

\subsection*{Esempio: conteggio con while}
\begin{lstlisting}
n = 1
while n <= 5:
    print(n)
    n += 1
\end{lstlisting}

\subsection*{Esempio: somma dei numeri inseriti}
\begin{lstlisting}
somma = 0
while True:
    numero = input("Inserisci un numero (q per uscire): ")
    if numero == "q":
        break
    somma += int(numero)
print("Somma totale:", somma)
\end{lstlisting}

\subsection*{Attenzione ai loop infiniti}
Se dimentichi di aggiornare la variabile di controllo o la condizione non diventa mai falsa, il ciclo non termina mai:
\begin{lstlisting}
x = 5
while x > 0:
    print(x)
    # x non viene mai modificato: ciclo infinito!
\end{lstlisting}

\subsection*{Uso con valori "falsy"}
Il ciclo \texttt{while} può essere usato con qualsiasi espressione che restituisce un valore booleano:
\begin{lstlisting}
lista = [1, 2, 3]
while lista:
    elemento = lista.pop()
    print(elemento)
# Il ciclo termina quando la lista e' vuota (valore "falsy")
\end{lstlisting}

\subsection*{Nidificazione di while}
Puoi annidare cicli \texttt{while} all'interno di altri cicli \texttt{while}:
\begin{lstlisting}
i = 1
while i <= 3:
    j = 1
    while j <= 2:
        print(f"i={i}, j={j}")
        j += 1
    i += 1
\end{lstlisting}

\subsection*{Quando usare while invece di for}
Usa \texttt{while} quando:
\begin{itemize}
    \item Non conosci a priori il numero di iterazioni.
    \item Vuoi ripetere un blocco finché una condizione è vera.
    \item Gestisci input utente o condizioni che possono cambiare dinamicamente.
\end{itemize}
Se invece conosci il numero di iterazioni o devi scorrere una sequenza, è preferibile usare il ciclo \texttt{for}.

\subsection*{Riepilogo}
\begin{itemize}
    \item Il ciclo \texttt{while} ripete un blocco finché la condizione è vera.
    \item Attenzione ai loop infiniti: aggiorna sempre la variabile di controllo.
    \item Puoi usare \texttt{break} per uscire dal ciclo e \texttt{continue} per saltare all'iterazione successiva.
    \item La clausola \texttt{else} viene eseguita solo se il ciclo termina normalmente.
\end{itemize}

\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{RICORDA:} Il ciclo \texttt{while} è molto potente, ma va usato con attenzione per evitare cicli infiniti!
        }
    }
\end{center}

\section{Ciclo For}
Il ciclo \texttt{for} in Python è uno strumento fondamentale per iterare su sequenze (come liste, tuple, stringhe, dizionari, insiemi) e su oggetti iterabili in generale. È molto versatile e permette di eseguire un blocco di codice per ogni elemento di una sequenza.

\subsection*{Sintassi di base}
La sintassi generale del ciclo \texttt{for} è:
\begin{lstlisting}
for variabile in sequenza:
    # blocco di istruzioni
\end{lstlisting}
Ad ogni iterazione, la variabile assume il valore successivo della sequenza, fino a che la sequenza è esaurita.

\subsection*{Esempio semplice}
\begin{lstlisting}
frutti = ["mela", "banana", "ciliegia"]
for frutto in frutti:
    print(frutto)
# Output:
# mela
# banana
# ciliegia
\end{lstlisting}

\subsection*{Iterazione su stringhe}
Le stringhe sono sequenze di caratteri, quindi puoi iterare su ogni carattere:
\begin{lstlisting}
parola = "Python"
for lettera in parola:
    print(lettera)
# Output:
# P
# y
# t
# h
# o
# n
\end{lstlisting}

\subsection*{Iterazione su tuple, set e dizionari}
\textbf{Tuple:}
\begin{lstlisting}
coordinate = (10, 20, 30)
for valore in coordinate:
    print(valore)
\end{lstlisting}

\textbf{Set:} (l'ordine non è garantito)
\begin{lstlisting}
numeri = {1, 2, 3}
for n in numeri:
    print(n)
\end{lstlisting}

\textbf{Dizionari:}
\begin{lstlisting}
diz = {"a": 1, "b": 2, "c": 3}
for chiave in diz:
    print(chiave, diz[chiave])
# oppure
for chiave, valore in diz.items():
    print(chiave, valore)
\end{lstlisting}

\subsection*{La funzione \texttt{range()}}
\texttt{range()} genera una sequenza di numeri interi, molto usata nei cicli \texttt{for}:
\begin{lstlisting}
for i in range(5):
    print(i)
# Output: 0 1 2 3 4
\end{lstlisting}
\texttt{range(start, stop, step)}:
\begin{lstlisting}
for i in range(2, 10, 2):
    print(i)
# Output: 2 4 6 8
\end{lstlisting}

\subsection*{Iterazione inversa}
Puoi iterare all'indietro usando un passo negativo:
\begin{lstlisting}
for i in range(5, 0, -1):
    print(i)
# Output: 5 4 3 2 1
\end{lstlisting}

\subsection*{Enumerare una sequenza}
\texttt{enumerate()} restituisce coppie (indice, valore):
\begin{lstlisting}
frutti = ["mela", "banana", "ciliegia"]
for indice, frutto in enumerate(frutti):
    print(indice, frutto)
# Output:
# 0 mela
# 1 banana
# 2 ciliegia
\end{lstlisting}

\subsection*{Iterare su più sequenze contemporaneamente}
\texttt{zip()} permette di iterare su più sequenze in parallelo:
\begin{lstlisting}
nomi = ["Anna", "Luca", "Marta"]
eta = [25, 30, 22]
for nome, anni in zip(nomi, eta):
    print(nome, anni)
# Output:
# Anna 25
# Luca 30
# Marta 22
\end{lstlisting}

\subsection*{Istruzione \texttt{break}}
Interrompe il ciclo prima che la sequenza sia esaurita:
\begin{lstlisting}
for n in range(10):
    if n == 5:
        break
    print(n)
# Output: 0 1 2 3 4
\end{lstlisting}

\subsection*{Istruzione \texttt{continue}}
Salta l'iterazione corrente e passa alla successiva:
\begin{lstlisting}
for n in range(5):
    if n == 2:
        continue
    print(n)
# Output: 0 1 3 4
\end{lstlisting}

\subsection*{Istruzione \texttt{else} con for}
Il blocco \texttt{else} viene eseguito solo se il ciclo termina normalmente (non tramite \texttt{break}):
\begin{lstlisting}
for n in range(3):
    print(n)
else:
    print("Ciclo terminato")
# Output:
# 0
# 1
# 2
# Ciclo terminato
\end{lstlisting}

Se il ciclo viene interrotto con \texttt{break}, il blocco \texttt{else} non viene eseguito:
\begin{lstlisting}
for n in range(3):
    if n == 1:
        break
    print(n)
else:
    print("Ciclo terminato")
# Output:
# 0
\end{lstlisting}

\subsection*{Ciclo for annidato (nested for)}
Puoi inserire un ciclo \texttt{for} dentro un altro:
\begin{lstlisting}
for i in range(1, 4):
    for j in range(1, 3):
        print(f"i={i}, j={j}")
\end{lstlisting}

\subsection*{Modifica di una sequenza durante l'iterazione}
Non è consigliato modificare una lista mentre la stai iterando. Se devi rimuovere elementi, crea una copia:
\begin{lstlisting}
numeri = [1, 2, 3, 4]
for n in numeri[:]:  # copia della lista
    if n % 2 == 0:
        numeri.remove(n)
print(numeri)  # [1, 3]
\end{lstlisting}

\subsection*{Comprensioni di lista (list comprehension)}
Una forma compatta per creare nuove liste:
\begin{lstlisting}
quadrati = [x**2 for x in range(5)]
print(quadrati)  # [0, 1, 4, 9, 16]
\end{lstlisting}
Puoi aggiungere condizioni:
\begin{lstlisting}
pari = [x for x in range(10) if x % 2 == 0]
print(pari)  # [0, 2, 4, 6, 8]
\end{lstlisting}

\subsection*{Iterazione su oggetti personalizzati}
Un oggetto può essere iterato in un ciclo \texttt{for} se implementa il metodo speciale \texttt{\_\_iter\_\_()} e restituisce un iteratore (che implementa \texttt{\_\_next\_\_()}):
\begin{lstlisting}
class Contatore:
    def __init__(self, limite):
        self.limite = limite
        self.valore = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.valore < self.limite:
            self.valore += 1
            return self.valore
        else:
            raise StopIteration

for n in Contatore(3):
    print(n)
# Output: 1 2 3
\end{lstlisting}

\subsection*{Iterazione su file}
Puoi iterare direttamente sulle righe di un file:
\begin{lstlisting}
with open("file.txt") as f:
    for riga in f:
        print(riga.strip())
\end{lstlisting}

\subsection*{Iterazione su dizionari: chiavi, valori, coppie}
\begin{lstlisting}
d = {"a": 1, "b": 2}
for chiave in d:
    print(chiave)
for valore in d.values():
    print(valore)
for chiave, valore in d.items():
    print(chiave, valore)
\end{lstlisting}

\subsection*{Iterazione su oggetti non indicizzabili}
Non tutte le sequenze sono indicizzabili (come i set), ma puoi comunque iterare su di esse con \texttt{for}.

\subsection*{Riepilogo e consigli}
\begin{itemize}
    \item Il ciclo \texttt{for} è ideale per scorrere sequenze e oggetti iterabili.
    \item Usa \texttt{range()} per iterare su intervalli di numeri.
    \item Puoi usare \texttt{break}, \texttt{continue} ed \texttt{else} per controllare il flusso.
    \item Le comprensioni di lista sono una forma compatta e potente di ciclo \texttt{for}.
    \item Puoi annidare cicli \texttt{for} per lavorare su strutture complesse (matrici, tabelle, ecc.).
    \item Non modificare la sequenza su cui stai iterando, a meno che non sia una copia.
    \item Il ciclo \texttt{for} è preferibile al \texttt{while} quando conosci la sequenza o il numero di iterazioni.
\end{itemize}

\begin{center}
    \fcolorbox{red}{yellow!30}{
        \parbox{0.9\linewidth}{
            \textbf{RICORDA:} In Python il ciclo \texttt{for} funziona su qualsiasi oggetto iterabile, non solo su liste!
        }
    }
\end{center}

\section{Collezione di dati}
Le collezioni di dati in Python sono strutture che permettono di raggruppare più valori in un'unica variabile. Sono fondamentali per gestire insiemi di dati, manipolarli, ordinarli, filtrarli e molto altro. Python offre diversi tipi di collezioni, ognuna con caratteristiche specifiche:

\begin{itemize}
    \item \textbf{Liste (list)}
    \item \textbf{Tuple (tuple)}
    \item \textbf{Set (set)}
    \item \textbf{Dizionari (dict)}
    \item \textbf{Frozenset (frozenset)}
\end{itemize}

Vediamo in dettaglio ciascuna di queste collezioni.

\subsection*{Liste (\texttt{list})}
Le liste sono collezioni ordinate, modificabili (mutabili) e possono contenere elementi duplicati di qualsiasi tipo.

\textbf{Creazione di una lista:}
\begin{lstlisting}
lista = [1, 2, 3, "Python", True]
\end{lstlisting}

\textbf{Caratteristiche principali:}
\begin{itemize}
    \item \textbf{Ordinata}: mantiene l'ordine di inserimento.
    \item \textbf{Indicizzabile}: puoi accedere agli elementi tramite indice (\texttt{lista[0]}).
    \item \textbf{Mutabile}: puoi modificare, aggiungere o rimuovere elementi.
    \item \textbf{Permette duplicati}: puoi avere più elementi uguali.
\end{itemize}

\textbf{Operazioni comuni sulle liste:}
\begin{lstlisting}
frutti = ["mela", "banana", "ciliegia"]
print(frutti[0])         # mela
frutti[1] = "pera"       # Modifica elemento
frutti.append("kiwi")    # Aggiunge in fondo
frutti.insert(1, "arancia") # Inserisce in posizione 1
frutti.remove("mela")    # Rimuove il primo valore uguale
elemento = frutti.pop()  # Rimuove e restituisce
                         #l'ultimo elemento
lunghezza = len(frutti)  # Lunghezza della lista
\end{lstlisting}

\textbf{Slicing:}
\begin{lstlisting}
numeri = [0, 1, 2, 3, 4, 5]
print(numeri[2:5])   # [2, 3, 4]
print(numeri[:3])    # [0, 1, 2]
print(numeri[::2])   # [0, 2, 4]
\end{lstlisting}

\textbf{Metodi utili:}
\begin{lstlisting}
lista.count(x)    # Conta le occorrenze di x
lista.index(x)    # Restituisce l'indice della
                  #prima occorrenza di x
lista.sort()      # Ordina la lista (in place)
lista.reverse()   # Inverte l'ordine (in place)
lista.copy()      # Restituisce una copia superficiale
lista.clear()     # Svuota la lista
\end{lstlisting}

\textbf{Liste annidate:}
\begin{lstlisting}
matrice = [[1, 2], [3, 4], [5, 6]]
print(matrice[1][0])  # 3
\end{lstlisting}

\subsection*{Tuple (\texttt{tuple})}
Le tuple sono collezioni ordinate e immutabili (non modificabili dopo la creazione). Permettono elementi duplicati.

\textbf{Creazione di una tupla:}
\begin{lstlisting}
tupla = (1, 2, 3, "Python")
\end{lstlisting}

\textbf{Caratteristiche principali:}
\begin{itemize}
    \item \textbf{Ordinata} e \textbf{indicizzabile}
    \item \textbf{Immutabile}: non puoi aggiungere, rimuovere o modificare elementi
    \item \textbf{Permette duplicati}
    \item Più veloce delle liste e usata per dati costanti
\end{itemize}

\textbf{Operazioni sulle tuple:}
\begin{lstlisting}
print(tupla[0])      # 1
print(len(tupla))    # 4
nuova = tupla + (4,) # Concatenazione
\end{lstlisting}

\textbf{Unpacking:}
\begin{lstlisting}
a, b, c, d = tupla
\end{lstlisting}

\textbf{Tuple monoelemento:}
\begin{lstlisting}
t = (5,)  # Attenzione alla virgola!
\end{lstlisting}

\subsection*{Set (\texttt{set})}
I set sono collezioni non ordinate, mutabili e non indicizzate. Non permettono duplicati.

\textbf{Creazione di un set:}
\begin{lstlisting}
insieme = {1, 2, 3, 3, 2}
print(insieme)  # {1, 2, 3}
\end{lstlisting}

\textbf{Caratteristiche principali:}
\begin{itemize}
    \item \textbf{Non ordinato}: nessuna garanzia sull'ordine
    \item \textbf{Mutabile}: puoi aggiungere o rimuovere elementi
    \item \textbf{Nessun duplicato}
    \item \textbf{Non indicizzabile}
\end{itemize}

\textbf{Operazioni sui set:}
\begin{lstlisting}
insieme.add(4)         # Aggiunge un elemento
insieme.remove(2)      # Rimuove un elemento
                       #(errore se non esiste)
insieme.discard(5)     # Rimuove se esiste,
                       #altrimenti non fa nulla
insieme.pop()          # Rimuove un elemento casuale
insieme.clear()        # Svuota il set
\end{lstlisting}

\textbf{Operazioni insiemistiche:}
\begin{lstlisting}
a = {1, 2, 3}
b = {3, 4, 5}
print(a | b)   # Unione: {1, 2, 3, 4, 5}
print(a & b)   # Intersezione: {3}
print(a - b)   # Differenza: {1, 2}
print(a ^ b)   # Differenza simmetrica: {1, 2, 4, 5}
\end{lstlisting}

\subsection*{Dizionari (\texttt{dict})}
I dizionari sono collezioni non ordinate (in Python 3.7+ mantengono l'ordine di inserimento), mutabili e indicizzate tramite chiavi univoche.

\textbf{Creazione di un dizionario:}
\begin{lstlisting}
diz = {"nome": "Mario", "eta": 30}
\end{lstlisting}

\textbf{Caratteristiche principali:}
\begin{itemize}
    \item \textbf{Coppie chiave-valore}
    \item \textbf{Chiavi univoche} (immutabili: stringhe, numeri, tuple)
    \item \textbf{Valori di qualsiasi tipo}
    \item \textbf{Mutabile}
\end{itemize}

\textbf{Operazioni sui dizionari:}
\begin{lstlisting}
print(diz["nome"])        # Mario
diz["eta"] = 31           # Modifica valore
diz["citta"] = "Roma"     # Aggiunge nuova coppia
diz.pop("eta")            # Rimuove chiave e
                          #restituisce valore
valore = diz.get("email", "Non presente") # Accesso sicuro
chiavi = diz.keys()       # Tutte le chiavi
valori = diz.values()     # Tutti i valori
coppie = diz.items()      # Tutte le coppie (chiave, valore)
diz.clear()               # Svuota il dizionario
\end{lstlisting}

\textbf{Iterazione su dizionari:}
\begin{lstlisting}
for chiave in diz:
    print(chiave, diz[chiave])
for chiave, valore in diz.items():
    print(chiave, valore)
\end{lstlisting}

\subsection*{Frozenset (\texttt{frozenset})}
Il \texttt{frozenset} è una variante immutabile del set. Una volta creato, non può essere modificato.

\textbf{Creazione:}
\begin{lstlisting}
f = frozenset([1, 2, 3])
\end{lstlisting}

\textbf{Caratteristiche:}
\begin{itemize}
    \item \textbf{Immutabile}
    \item \textbf{Nessun duplicato}
    \item Supporta operazioni insiemistiche come i set
\end{itemize}

\subsection*{Conversione tra collezioni}
Puoi convertire tra diversi tipi di collezioni:
\begin{lstlisting}
lista = [1, 2, 3]
tupla = tuple(lista)
insieme = set(lista)
diz = dict([("a", 1), ("b", 2)])
\end{lstlisting}

\subsection*{Comprensioni (Comprehensions)}
Le comprensioni permettono di creare collezioni in modo compatto:
\begin{lstlisting}
# Lista dei quadrati
quadrati = [x**2 for x in range(5)]
# Set delle lettere uniche in una parola
lettere = {c for c in "banana"}
# Dizionario di numeri e loro quadrati
d = {x: x**2 for x in range(3)}
\end{lstlisting}

\subsection*{Collezioni annidate}
Puoi avere collezioni dentro altre collezioni:
\begin{lstlisting}
matrice = [[1, 2], [3, 4]]
diz = {"nomi": ["Anna", "Luca"], "eta": [20, 30]}
\end{lstlisting}

\subsection*{Moduli avanzati: \texttt{collections}}
Il modulo \texttt{collections} offre collezioni speciali:
\begin{itemize}
    \item \texttt{namedtuple}: tuple con nomi ai campi
    \item \texttt{deque}: lista doppiamente terminata (più efficiente per inserimenti/rimozioni alle estremità)
    \item \texttt{Counter}: conteggio di elementi hashable
    \item \texttt{OrderedDict}: dizionario ordinato (in Python 3.7+ i dict standard sono già ordinati)
    \item \texttt{defaultdict}: dizionario con valore di default per chiavi mancanti
    \item \texttt{ChainMap}: unisce più dizionari in una sola vista
\end{itemize}

\textbf{Esempi:}
\begin{lstlisting}
from collections import Counter, deque, namedtuple, defaultdict

# Counter
conta = Counter("banana")
print(conta)  # Counter({'a': 3, 'b': 1, 'n': 2})

# deque
dq = deque([1, 2, 3])
dq.appendleft(0)
dq.append(4)
dq.pop()
dq.popleft()

# namedtuple
Punto = namedtuple("Punto", ["x", "y"])
p = Punto(1, 2)
print(p.x, p.y)

# defaultdict
d = defaultdict(int)
d["a"] += 1
print(d["a"])  # 1
print(d["b"])  # 0 (valore di default)
\end{lstlisting}

\subsection*{Mutabilità e immutabilità}
\begin{itemize}
    \item \textbf{Mutabili}: list, set, dict, deque
    \item \textbf{Immutabili}: tuple, frozenset, namedtuple
\end{itemize}

\subsection*{Quando usare quale collezione}
\begin{itemize}
    \item \textbf{list}: sequenze ordinate e modificabili, accesso rapido per indice
    \item \textbf{tuple}: dati costanti, chiavi di dizionari, sicurezza da modifiche
    \item \textbf{set}: insiemi di elementi unici, operazioni insiemistiche
    \item \textbf{frozenset}: insiemi immutabili, chiavi di dizionari/set
    \item \textbf{dict}: associazioni chiave-valore, lookup rapido per chiave
    \item \textbf{deque}: code e pile efficienti
    \item \textbf{Counter}: conteggio frequenze
    \item \textbf{defaultdict}: dizionari con valori di default
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Lista di nomi unici ordinati alfabeticamente
nomi = ["Anna", "Luca", "Anna", "Marco"]
nomi_unici = sorted(set(nomi))

# Dizionario da due liste
chiavi = ["a", "b", "c"]
valori = [1, 2, 3]
diz = dict(zip(chiavi, valori))

# Lista piatta da lista di liste
liste = [[1, 2], [3, 4], [5]]
piatta = [x for sub in liste for x in sub]
\end{lstlisting}

\subsection*{Conclusioni}
Le collezioni di dati sono strumenti essenziali in Python per organizzare, manipolare e analizzare dati. Scegli la collezione più adatta in base alle esigenze di ordinamento, mutabilità, unicità e tipo di accesso richiesto. La conoscenza approfondita di queste strutture è fondamentale per scrivere codice Python efficiente e leggibile.

\section{Liste}
Le \textbf{liste} in Python sono una delle strutture dati più versatili e utilizzate. Permettono di memorizzare una sequenza ordinata di elementi, che possono essere di qualsiasi tipo (numeri, stringhe, oggetti, altre liste, ecc.). Le liste sono \textbf{mutabili}, cioè possono essere modificate dopo la loro creazione.

\subsection*{Creazione di una lista}
Puoi creare una lista racchiudendo gli elementi tra parentesi quadre \texttt{[]} separati da virgole:
\begin{lstlisting}
lista_vuota = []
numeri = [1, 2, 3, 4, 5]
mista = [1, "ciao", 3.14, True]
annidata = [1, [2, 3], 4]
\end{lstlisting}

\subsection*{Accesso agli elementi}
Gli elementi sono indicizzati a partire da 0:
\begin{lstlisting}
frutti = ["mela", "banana", "ciliegia"]
print(frutti[0])   # mela
print(frutti[1])   # banana
print(frutti[-1])  # ciliegia (indice negativo:
                   #conta da destra)
\end{lstlisting}

\subsection*{Slicing (fette di lista)}
Puoi ottenere sotto-liste usando la notazione \texttt{lista[start:stop:step]}:
\begin{lstlisting}
numeri = [0, 1, 2, 3, 4, 5, 6]
print(numeri[2:5])    # [2, 3, 4]
print(numeri[:3])     # [0, 1, 2]
print(numeri[::2])    # [0, 2, 4, 6]
print(numeri[::-1])   # [6, 5, 4, 3, 2, 1, 0]
                      #(lista invertita)
\end{lstlisting}

\subsection*{Modifica degli elementi}
Le liste sono mutabili:
\begin{lstlisting}
frutti[1] = "pera"
print(frutti)  # ["mela", "pera", "ciliegia"]
\end{lstlisting}

\subsection*{Aggiunta di elementi}
\begin{itemize}
    \item \texttt{append(x)}: aggiunge \texttt{x} in fondo alla lista
    \item \texttt{insert(i, x)}: inserisce \texttt{x} in posizione \texttt{i}
    \item \texttt{extend(iterabile)}: aggiunge tutti gli elementi di un iterabile
\end{itemize}
\begin{lstlisting}
frutti.append("kiwi")
frutti.insert(1, "arancia")
frutti.extend(["uva", "melone"])
\end{lstlisting}

\subsection*{Rimozione di elementi}
\begin{itemize}
    \item \texttt{remove(x)}: rimuove la prima occorrenza di \texttt{x}
    \item \texttt{pop([i])}: rimuove e restituisce l'elemento in posizione \texttt{i} (default: ultimo)
    \item \texttt{clear()}: svuota la lista
    \item \texttt{del lista[i]}: elimina l'elemento in posizione \texttt{i}
\end{itemize}
\begin{lstlisting}
frutti.remove("pera")
ultimo = frutti.pop()
del frutti[0]
frutti.clear()
\end{lstlisting}

\subsection*{Ricerca di elementi}
\begin{itemize}
    \item \texttt{in}: verifica se un elemento è presente
    \item \texttt{index(x, [start, end])}: restituisce l'indice della prima occorrenza di \texttt{x}
    \item \texttt{count(x)}: conta le occorrenze di \texttt{x}
\end{itemize}
\begin{lstlisting}
if "banana" in frutti:
    print("Presente!")
pos = frutti.index("ciliegia")
n = frutti.count("mela")
\end{lstlisting}

\subsection*{Ordinamento e inversione}
\begin{itemize}
    \item \texttt{sort()}: ordina la lista in place (modifica la lista)
    \item \texttt{sorted(lista)}: restituisce una nuova lista ordinata
    \item \texttt{reverse()}: inverte l'ordine degli elementi
\end{itemize}
\begin{lstlisting}
numeri = [3, 1, 4, 2]
numeri.sort()
numeri.reverse()
ordinata = sorted(numeri)
\end{lstlisting}

\subsection*{Copia di una lista}
Attenzione: l'assegnamento crea un alias, non una copia!
\begin{lstlisting}
a = [1, 2, 3]
b = a          # b e' un alias di a
c = a.copy()   # copia superficiale
d = list(a)    # altra copia superficiale
e = a[:]       # copia tramite slicing
\end{lstlisting}

\subsection*{Liste annidate (matrici)}
Le liste possono contenere altre liste:
\begin{lstlisting}
matrice = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matrice[1][2])  # 6
\end{lstlisting}

\subsection*{Iterazione su una lista}
\begin{lstlisting}
for elemento in frutti:
    print(elemento)
for i, elemento in enumerate(frutti):
    print(i, elemento)
\end{lstlisting}

\subsection*{Comprensioni di lista}
Modo compatto per creare nuove liste:
\begin{lstlisting}
quadrati = [x**2 for x in range(10)]
pari = [x for x in range(20) if x % 2 == 0]
\end{lstlisting}

\subsection*{Funzioni e metodi utili}
\begin{itemize}
    \item \texttt{len(lista)}: lunghezza
    \item \texttt{min(lista)}, \texttt{max(lista)}, \texttt{sum(lista)}
    \item \texttt{any(lista)}, \texttt{all(lista)}
    \item \texttt{zip()}, \texttt{map()}, \texttt{filter()}
\end{itemize}
\begin{lstlisting}
print(len(frutti))
print(min(numeri), max(numeri), sum(numeri))
\end{lstlisting}

\subsection*{Concatenazione e ripetizione}
\begin{lstlisting}
a = [1, 2]
b = [3, 4]
c = a + b         # [1, 2, 3, 4]
d = a * 3         # [1, 2, 1, 2, 1, 2]
\end{lstlisting}

\subsection*{Mutabilità e aliasing}
Le liste sono mutabili: modificare una lista tramite un alias modifica anche l'originale.
\begin{lstlisting}
a = [1, 2, 3]
b = a
b[0] = 99
print(a)  # [99, 2, 3]
\end{lstlisting}

\subsection*{Copia profonda (deep copy)}
Se la lista contiene altre liste (annidate), la copia superficiale non basta:
\begin{lstlisting}
import copy
matrice = [[1, 2], [3, 4]]
copia_profonda = copy.deepcopy(matrice)
\end{lstlisting}

\subsection*{Metodi principali delle liste}
\begin{itemize}
    \item \texttt{append(x)}
    \item \texttt{extend(iterabile)}
    \item \texttt{insert(i, x)}
    \item \texttt{remove(x)}
    \item \texttt{pop([i])}
    \item \texttt{clear()}
    \item \texttt{index(x, [start, end])}
    \item \texttt{count(x)}
    \item \texttt{sort(key=None, reverse=False)}
    \item \texttt{reverse()}
    \item \texttt{copy()}
\end{itemize}

\subsection*{Liste di oggetti}
Le liste possono contenere oggetti di qualsiasi tipo, inclusi oggetti personalizzati:
\begin{lstlisting}
class Persona:
    def __init__(self, nome):
        self.nome = nome

persone = [Persona("Anna"), Persona("Luca")]
print(persone[0].nome)
\end{lstlisting}

\subsection*{Liste come stack e queue}
\textbf{Stack (pila):} usa \texttt{append()} e \texttt{pop()}
\begin{lstlisting}
stack = []
stack.append(1)
stack.append(2)
x = stack.pop()  # 2
\end{lstlisting}
\textbf{Queue (coda):} per efficienza usa \texttt{collections.deque}, ma con le liste:
\begin{lstlisting}
queue = [1, 2, 3]
x = queue.pop(0)  # 1 (inefficiente per liste lunghe)
\end{lstlisting}

\subsection*{Conversione da e verso altri tipi}
\begin{lstlisting}
lista = list("ciao")  # ['c', 'i', 'a', 'o']
stringa = "".join(lista)  # 'ciao'
\end{lstlisting}

\subsection*{Liste e funzioni}
Le liste possono essere passate come argomenti e restituite dalle funzioni:
\begin{lstlisting}
def somma_lista(l):
    return sum(l)

risultato = somma_lista([1, 2, 3])
\end{lstlisting}

\subsection*{Liste e unpacking}
\begin{lstlisting}
a, b, c = [1, 2, 3]
x, *resto = [10, 20, 30, 40]  # x=10, resto=[20, 30, 40]
\end{lstlisting}

\subsection*{Liste e generatori}
Puoi convertire un generatore in lista:
\begin{lstlisting}
gen = (x**2 for x in range(5))
lista = list(gen)
\end{lstlisting}

\subsection*{Limitazioni delle liste}
\begin{itemize}
    \item Non sono thread-safe
    \item Non sono efficienti per inserimenti/rimozioni in testa (usa \texttt{deque})
    \item Non sono tipizzate (possono contenere tipi diversi)
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Rimuovere duplicati mantenendo l'ordine
lista = [1, 2, 2, 3, 1]
senza_duplicati = []
for x in lista:
    if x not in senza_duplicati:
        senza_duplicati.append(x)

# Flatten di una lista di liste
liste = [[1, 2], [3, 4], [5]]
piatta = [x for sub in liste for x in sub]
\end{lstlisting}

\subsection*{Conclusioni}
Le liste sono fondamentali in Python per la gestione di sequenze di dati. Sono flessibili, potenti e supportano numerose operazioni. La loro conoscenza approfondita è essenziale per programmare in Python in modo efficace.

\section{Tuple}
Le \textbf{tuple} in Python sono una delle strutture dati fondamentali. Sono simili alle liste, ma con una differenza chiave: \textbf{le tuple sono immutabili}, cioè una volta create non possono essere modificate (non puoi aggiungere, rimuovere o cambiare i loro elementi). Questa caratteristica le rende utili in molti contesti dove la sicurezza e l'integrità dei dati sono importanti.

\subsection*{Creazione di una tupla}
Puoi creare una tupla racchiudendo gli elementi tra parentesi tonde \texttt{()} separati da virgole:
\begin{lstlisting}
tupla = (1, 2, 3)
vuota = ()
singolo = (5,)  # Attenzione alla virgola!
\end{lstlisting}
\textbf{Nota:} Per creare una tupla con un solo elemento, è obbligatorio mettere la virgola dopo l'elemento, altrimenti Python la interpreta come un'espressione tra parentesi.

Puoi anche creare tuple senza parentesi, separando gli elementi con la virgola:
\begin{lstlisting}
tupla = 1, 2, 3
\end{lstlisting}

\subsection*{Accesso agli elementi}
Le tuple sono indicizzate e ordinate, quindi puoi accedere agli elementi tramite l'indice:
\begin{lstlisting}
t = (10, 20, 30)
print(t[0])    # 10
print(t[-1])   # 30 (indice negativo: conta da destra)
\end{lstlisting}

\subsection*{Slicing}
Come le liste, puoi ottenere sotto-tuple tramite slicing:
\begin{lstlisting}
t = (0, 1, 2, 3, 4)
print(t[1:4])    # (1, 2, 3)
print(t[:3])     # (0, 1, 2)
print(t[::-1])   # (4, 3, 2, 1, 0) (tupla invertita)
\end{lstlisting}

\subsection*{Immutabilità}
Le tuple non possono essere modificate dopo la creazione:
\begin{lstlisting}
t = (1, 2, 3)
# t[0] = 10  # Errore: TypeError
# t.append(4)  # Errore: AttributeError
\end{lstlisting}
Tuttavia, se una tupla contiene oggetti mutabili (come liste), questi oggetti possono essere modificati:
\begin{lstlisting}
t = (1, [2, 3], 4)
t[1][0] = 99
print(t)  # (1, [99, 3], 4)
\end{lstlisting}

\subsection*{Quando usare le tuple}
\begin{itemize}
    \item Quando vuoi dati costanti che non devono essere modificati.
    \item Come chiavi nei dizionari (le tuple sono hashable se contengono solo oggetti immutabili).
    \item Come valori di ritorno multipli da una funzione.
    \item Per garantire l'integrità dei dati.
    \item Per efficienza: le tuple sono più leggere e veloci delle liste.
\end{itemize}

\subsection*{Operazioni sulle tuple}
\begin{itemize}
    \item \texttt{len(tupla)}: lunghezza della tupla.
    \item \texttt{tupla + tupla2}: concatenazione.
    \item \texttt{tupla * n}: ripetizione.
    \item \texttt{in}, \texttt{not in}: verifica presenza elemento.
    \item \texttt{tupla.count(x)}: conta le occorrenze di x.
    \item \texttt{tupla.index(x)}: indice della prima occorrenza di x.
\end{itemize}
\begin{lstlisting}
t = (1, 2, 3)
print(len(t))         # 3
print(t + (4, 5))     # (1, 2, 3, 4, 5)
print(t * 2)          # (1, 2, 3, 1, 2, 3)
print(2 in t)         # True
print(t.count(1))     # 1
print(t.index(3))     # 2
\end{lstlisting}

\subsection*{Unpacking delle tuple}
Puoi assegnare i valori di una tupla a più variabili in una sola riga:
\begin{lstlisting}
t = (10, 20, 30)
a, b, c = t
print(a, b, c)  # 10 20 30
\end{lstlisting}
Puoi anche usare l'unpacking esteso:
\begin{lstlisting}
t = (1, 2, 3, 4, 5)
a, *b, c = t
print(a)  # 1
print(b)  # [2, 3, 4]
print(c)  # 5
\end{lstlisting}

\subsection*{Tuple come valori di ritorno multipli}
Le funzioni possono restituire più valori usando una tupla:
\begin{lstlisting}
def divmod(a, b):
    return a // b, a % b

q, r = divmod(17, 5)
print(q, r)  # 3 2
\end{lstlisting}

\subsection*{Tuple annidate}
Le tuple possono contenere altre tuple (o altri oggetti):
\begin{lstlisting}
t = ((1, 2), (3, 4), (5, 6))
print(t[1][0])  # 3
\end{lstlisting}

\subsection*{Tuple e dizionari}
Le tuple possono essere usate come chiavi nei dizionari, purché siano composte solo da oggetti immutabili:
\begin{lstlisting}
d = { (1, 2): "a", (3, 4): "b" }
print(d[(1, 2)])  # "a"
\end{lstlisting}

\subsection*{Tuple e funzioni built-in}
Molte funzioni Python accettano tuple come argomenti:
\begin{lstlisting}
min((3, 1, 2))  # 1
max((3, 1, 2))  # 3
sum((1, 2, 3))  # 6
\end{lstlisting}

\subsection*{Tuple e comprensioni}
Non esistono "tuple comprehension", ma puoi creare una tupla da una list comprehension usando \texttt{tuple()}:
\begin{lstlisting}
t = tuple(x**2 for x in range(5))  # (0, 1, 4, 9, 16)
\end{lstlisting}

\subsection*{Tuple e metodi}
Le tuple hanno solo due metodi: \texttt{count()} e \texttt{index()}.
\begin{lstlisting}
t = (1, 2, 2, 3)
print(t.count(2))   # 2
print(t.index(3))   # 3
\end{lstlisting}

\subsection*{Tuple e performance}
Le tuple sono più leggere e veloci delle liste per:
\begin{itemize}
    \item Creazione e accesso agli elementi.
    \item Iterazione.
    \item Uso come chiavi nei dizionari/set.
\end{itemize}
Questo perché Python può ottimizzare le tuple grazie alla loro immutabilità.

\subsection*{Tuple e sicurezza}
L'immutabilità delle tuple garantisce che i dati non vengano accidentalmente modificati, rendendole ideali per:
\begin{itemize}
    \item Costanti.
    \item Dati di configurazione.
    \item Argomenti di funzioni che non devono essere alterati.
\end{itemize}

\subsection*{Tuple e oggetti mutabili}
Se una tupla contiene oggetti mutabili (come liste), la tupla resta immutabile, ma gli oggetti interni possono essere modificati:
\begin{lstlisting}
t = ([1, 2], 3)
t[0].append(4)
print(t)  # ([1, 2, 4], 3)
\end{lstlisting}

\subsection*{Tuple monoelemento}
Per creare una tupla con un solo elemento, serve la virgola:
\begin{lstlisting}
t = (5,)   # tupla
t2 = (5)   # non e' una tupla, e' un int
\end{lstlisting}

\subsection*{Tuple vuote}
La tupla vuota si scrive con le parentesi tonde senza elementi:
\begin{lstlisting}
t = ()
\end{lstlisting}

\subsection*{Conversione tra tuple e altri tipi}
\begin{lstlisting}
lista = [1, 2, 3]
t = tuple(lista)
l = list(t)
\end{lstlisting}

\subsection*{Tuple e unpacking con funzioni}
Puoi passare una tupla come argomenti a una funzione usando l'operatore \texttt{*}:
\begin{lstlisting}
def somma(a, b, c):
    return a + b + c

t = (1, 2, 3)
print(somma(*t))  # 6
\end{lstlisting}

\subsection*{Namedtuple}
Il modulo \texttt{collections} offre le \texttt{namedtuple}, tuple con campi accessibili per nome:
\begin{lstlisting}
from collections import namedtuple
Punto = namedtuple("Punto", ["x", "y"])
p = Punto(1, 2)
print(p.x, p.y)  # 1 2
\end{lstlisting}
Le \texttt{namedtuple} sono immutabili come le tuple normali.

\subsection*{Tuple e hashabilità}
Le tuple sono hashable se tutti i loro elementi sono hashable (cioè immutabili). Questo permette di usarle come chiavi nei dizionari e come elementi nei set.

\subsection*{Differenze tra tuple e liste}
\begin{itemize}
    \item \textbf{Mutabilità}: le liste sono mutabili, le tuple no.
    \item \textbf{Metodi}: le liste hanno molti metodi, le tuple solo \texttt{count()} e \texttt{index()}.
    \item \textbf{Prestazioni}: le tuple sono più veloci e leggere.
    \item \textbf{Uso}: le tuple per dati costanti, le liste per dati variabili.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Scambio di variabili
a, b = 1, 2
a, b = b, a

# Iterazione su lista di tuple
dati = [("Anna", 25), ("Luca", 30)]
for nome, eta in dati:
    print(nome, eta)

# Uso come chiavi di dizionario
coordinate = {}
coordinate[(45.0, 9.0)] = "Milano"
\end{lstlisting}

\subsection*{Conclusioni}
Le tuple sono fondamentali in Python per rappresentare sequenze di dati costanti, garantire l'integrità delle informazioni e migliorare le prestazioni. La loro immutabilità le rende sicure e adatte a molti scenari, come chiavi di dizionari, valori di ritorno multipli e strutture dati complesse. La conoscenza approfondita delle tuple è essenziale per una programmazione Python efficace e sicura.

\section{Set}
I \textbf{set} in Python sono una struttura dati fondamentale per rappresentare insiemi di elementi unici, non ordinati e mutabili. Sono ispirati alla teoria degli insiemi della matematica e permettono di eseguire efficientemente operazioni insiemistiche come unione, intersezione, differenza e differenza simmetrica.

\subsection*{Caratteristiche principali dei set}
\begin{itemize}
    \item \textbf{Non ordinati}: gli elementi non hanno un ordine definito e non sono accessibili tramite indice.
    \item \textbf{Elementi unici}: ogni elemento può comparire una sola volta.
    \item \textbf{Mutabili}: puoi aggiungere e rimuovere elementi dopo la creazione.
    \item \textbf{Non indicizzabili}: non puoi accedere agli elementi tramite indice o slicing.
    \item \textbf{Elementi hashable}: solo oggetti immutabili (hashable) possono essere inseriti in un set (es. numeri, stringhe, tuple di oggetti immutabili).
\end{itemize}

\subsection*{Creazione di un set}
\begin{lstlisting}
# Set vuoto (attenzione: {} crea un dizionario!)
s = set()
# Set con elementi
numeri = {1, 2, 3, 4}
# Da lista, tuple, stringhe
s = set([1, 2, 2, 3])      # {1, 2, 3}
s = set((4, 5, 6, 4))      # {4, 5, 6}
s = set("banana")          # {'b', 'a', 'n'}
\end{lstlisting}
\textbf{Nota:} \texttt{\{\}} crea un dizionario vuoto, non un set vuoto!

\subsection*{Elementi ammessi nei set}
Gli elementi devono essere \textbf{immutabili} e \textbf{hashable}:
\begin{itemize}
    \item Ammessi: int, float, str, tuple di oggetti immutabili, frozenset.
    \item Non ammessi: list, dict, set, oggetti mutabili.
\end{itemize}
\begin{lstlisting}
s = {1, 2, (3, 4)}
# s = {[1, 2]}  # Errore: lista non hashable
\end{lstlisting}

\subsection*{Operazioni fondamentali sui set}
\begin{itemize}
    \item \texttt{add(x)}: aggiunge l'elemento \texttt{x}
    \item \texttt{remove(x)}: rimuove \texttt{x} (errore se non esiste)
    \item \texttt{discard(x)}: rimuove \texttt{x} se esiste, altrimenti non fa nulla
    \item \texttt{pop()}: rimuove e restituisce un elemento arbitrario
    \item \texttt{clear()}: svuota il set
    \item \texttt{len(s)}: numero di elementi
    \item \texttt{in}, \texttt{not in}: verifica presenza elemento
\end{itemize}
\begin{lstlisting}
s = {1, 2, 3}
s.add(4)
s.remove(2)
s.discard(10)  # Non errore
x = s.pop()
s.clear()
\end{lstlisting}

\subsection*{Operazioni insiemistiche}
\begin{itemize}
    \item \texttt{|} oppure \texttt{union()}: unione
    \item \texttt{\&} oppure \texttt{intersection()}: intersezione
    \item \texttt{-} oppure \texttt{difference()}: differenza
    \item \texttt{\^} oppure \texttt{symmetric\_difference()}: differenza simmetrica
\end{itemize}
\begin{lstlisting}
a = {1, 2, 3}
b = {3, 4, 5}
print(a | b)   # {1, 2, 3, 4, 5}
print(a & b)   # {3}
print(a - b)   # {1, 2}
print(a ^ b)   # {1, 2, 4, 5}
\end{lstlisting}
\textbf{Nota:} Queste operazioni restituiscono un nuovo set, non modificano gli originali.

\subsection*{Metodi in-place (modifica del set)}
\begin{itemize}
    \item \texttt{update(iterabile)}: unione in-place
    \item \texttt{intersection\_update(iterabile)}: intersezione in-place
    \item \texttt{difference\_update(iterabile)}: differenza in-place
    \item \texttt{symmetric\_difference\_update(iterabile)}: differenza simmetrica in-place
\end{itemize}
\begin{lstlisting}
a = {1, 2, 3}
a.update([3, 4])  # a = {1, 2, 3, 4}
a.intersection_update({2, 3, 5})  # a = {2, 3}
\end{lstlisting}

\subsection*{Confronto tra set}
\begin{itemize}
    \item \texttt{==}, \texttt{!=}: uguaglianza
    \item \texttt{<=}, \texttt{<}: sottoinsieme (subset)
    \item \texttt{>=}, \texttt{>}: sovrainsieme (superset)
    \item \texttt{isdisjoint(other)}: True se non hanno elementi in comune
    \item \texttt{issubset(other)}: True se è sottoinsieme
    \item \texttt{issuperset(other)}: True se è sovrainsieme
\end{itemize}
\begin{lstlisting}
a = {1, 2}
b = {1, 2, 3}
print(a < b)  # True
print(b > a)  # True
print(a.issubset(b))  # True
print(b.issuperset(a))  # True
print(a.isdisjoint({3, 4}))  # True
\end{lstlisting}

\subsection*{Iterazione su un set}
\begin{lstlisting}
s = {"a", "b", "c"}
for elemento in s:
    print(elemento)
\end{lstlisting}
L'ordine di iterazione è arbitrario e può cambiare tra esecuzioni.

\subsection*{Set immutabili: frozenset}
\texttt{frozenset} è la versione immutabile del set:
\begin{lstlisting}
f = frozenset([1, 2, 3])
# f.add(4)  # Errore: AttributeError
\end{lstlisting}
Può essere usato come chiave di un dizionario o elemento di un altro set.

\subsection*{Conversione tra set e altri tipi}
\begin{lstlisting}
lista = [1, 2, 2, 3]
s = set(lista)         # {1, 2, 3}
l = list(s)            # [1, 2, 3] (ordine arbitrario)
t = tuple(s)           # (1, 2, 3)
\end{lstlisting}

\subsection*{Uso pratico dei set}
\begin{itemize}
    \item Rimuovere duplicati da una lista: \texttt{list(set(lista))}
    \item Test di appartenenza rapido: \texttt{x in s} è molto veloce
    \item Operazioni insiemistiche su grandi quantità di dati
    \item Filtrare elementi unici
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Rimuovere duplicati mantenendo l'ordine
lista = [1, 2, 2, 3, 1]
visti = set()
senza_duplicati = []
for x in lista:
    if x not in visti:
        senza_duplicati.append(x)
        visti.add(x)

# Parole uniche in una frase
frase = "il gatto e il cane"
parole_uniche = set(frase.split())
# {'gatto', 'e', 'il', 'cane'}

# Elementi comuni tra due liste
l1 = [1, 2, 3]
l2 = [2, 3, 4]
comuni = set(l1) & set(l2)  # {2, 3}
\end{lstlisting}

\subsection*{Limitazioni e attenzioni}
\begin{itemize}
    \item Gli elementi devono essere hashable (immutabili).
    \item L'ordine non è garantito.
    \item Non puoi accedere agli elementi tramite indice.
    \item Non puoi avere set di set (ma puoi avere set di frozenset).
\end{itemize}

\subsection*{Performance}
\begin{itemize}
    \item Le operazioni di appartenenza (\texttt{in}) e aggiunta/rimozione sono molto veloci (O(1) in media).
    \item Le operazioni insiemistiche sono ottimizzate.
\end{itemize}

\subsection*{Metodi principali dei set}
\begin{multicols}{2}
\begin{itemize}
    \item \texttt{add(x)}
    \item \texttt{remove(x)}
    \item \texttt{discard(x)}
    \item \texttt{pop()}
    \item \texttt{clear()}
    \item \texttt{union(*others)}
    \item \texttt{intersection(*others)}
    \item \texttt{difference(*others)}
    \item \texttt{symmetric\_difference(other)}
    \item \texttt{update(*others)}
    \item \texttt{intersection\_update(*others)}
    \item \texttt{difference\_update(*others)}
    \item \texttt{symmetric\_difference\_update(other)}
    \item \texttt{issubset(other)}
    \item \texttt{issuperset(other)}
    \item \texttt{isdisjoint(other)}
    \item \texttt{copy()}
\end{itemize}
\end{multicols}

\subsection*{Set comprehension}
Come le list comprehension, puoi creare set in modo compatto:
\begin{lstlisting}
quadrati = {x**2 for x in range(5)}  # {0, 1, 4, 9, 16}
pari = {x for x in range(10) if x % 2 == 0}
\end{lstlisting}

\subsection*{Set e funzioni built-in}
\begin{itemize}
    \item \texttt{len(s)}: numero di elementi
    \item \texttt{min(s)}, \texttt{max(s)}
    \item \texttt{sum(s)}
    \item \texttt{all(s)}, \texttt{any(s)}
    \item \texttt{sorted(s)}: restituisce una lista ordinata
\end{itemize}
\begin{lstlisting}
s = {3, 1, 2}
print(sorted(s))  # [1, 2, 3]
\end{lstlisting}

\subsection*{Set annidati}
Non puoi avere set di set (perché i set sono mutabili e non hashable), ma puoi avere set di frozenset:
\begin{lstlisting}
a = frozenset([1, 2])
b = frozenset([3, 4])
s = {a, b}
\end{lstlisting}

\subsection*{Differenze tra set, frozenset e dict}
\begin{itemize}
    \item \textbf{set}: mutabile, non ordinato, elementi unici, non indicizzabile.
    \item \textbf{frozenset}: come set, ma immutabile e hashable.
    \item \textbf{dict}: collezione di coppie chiave-valore, chiavi uniche e hashable.
\end{itemize}

\subsection*{Quando usare i set}
\begin{itemize}
    \item Quando serve garantire l'unicità degli elementi.
    \item Per operazioni insiemistiche (unione, intersezione, ecc.).
    \item Per test di appartenenza rapidi.
    \item Per rimuovere duplicati da sequenze.
\end{itemize}

\subsection*{Conclusioni}
I set sono strumenti potenti e versatili per la gestione di insiemi di dati unici e per operazioni insiemistiche efficienti. La loro conoscenza è fondamentale per scrivere codice Python efficace, pulito e performante, soprattutto quando si lavora con grandi quantità di dati o si devono garantire proprietà di unicità.

\section{Dizionari}
I \textbf{dizionari} (\texttt{dict}) in Python sono una delle strutture dati più potenti e versatili. Permettono di memorizzare coppie \textbf{chiave-valore}, dove ogni chiave è univoca e associata a un valore. Sono noti anche come \textit{mappe}, \textit{hashmap} o \textit{associative array} in altri linguaggi.

\subsection*{Caratteristiche principali dei dizionari}
\begin{itemize}
    \item \textbf{Collezione di coppie chiave-valore}: ogni elemento è formato da una chiave e un valore associato.
    \item \textbf{Chiavi univoche}: ogni chiave può comparire una sola volta.
    \item \textbf{Chiavi hashable}: le chiavi devono essere oggetti immutabili (stringhe, numeri, tuple di oggetti immutabili, ecc.).
    \item \textbf{Valori di qualsiasi tipo}: i valori possono essere di qualsiasi tipo (anche altri dizionari).
    \item \textbf{Mutabili}: puoi aggiungere, modificare o rimuovere coppie dopo la creazione.
    \item \textbf{Ordinati}: da Python 3.7+ mantengono l'ordine di inserimento (prima erano non ordinati).
    \item \textbf{Accesso rapido}: l'accesso ai valori tramite chiave è molto veloce (O(1) in media).
\end{itemize}

\subsection*{Creazione di un dizionario}
\begin{lstlisting}
# Dizionario vuoto
d = {}

# Dizionario con elementi
d = {"nome": "Mario", "eta": 30, "citta": "Roma"}

# Usando la funzione dict()
d = dict(nome="Anna", eta=25)

# Da lista di tuple/coppie
d = dict([("a", 1), ("b", 2)])

# Da zip di due liste
chiavi = ["x", "y"]
valori = [10, 20]
d = dict(zip(chiavi, valori))
\end{lstlisting}

\subsection*{Accesso ai valori}
\begin{lstlisting}
d = {"a": 1, "b": 2}
print(d["a"])         # 1

# Accesso sicuro con get()
print(d.get("c"))     # None
print(d.get("c", 0))  # 0 (valore di default)
\end{lstlisting}

\textbf{Nota:} Se accedi a una chiave inesistente con \texttt{d["chiave"]}, ottieni un \texttt{KeyError}. Usa \texttt{get()} per evitare errori.

\subsection*{Aggiunta e modifica di elementi}
\begin{lstlisting}
d["nuova"] = 123         # Aggiunge nuova coppia
d["a"] = 99              # Modifica valore esistente
\end{lstlisting}

\subsection*{Rimozione di elementi}
\begin{lstlisting}
d.pop("a")               # Rimuove e restituisce
                         #il valore associato a "a"
del d["b"]               # Rimuove la coppia con chiave "b"
d.popitem()              # Rimuove e restituisce l'ultima
                         #coppia (da Python 3.7+)
d.clear()                # Svuota il dizionario
\end{lstlisting}

\subsection*{Verifica presenza di una chiave}
\begin{lstlisting}
if "nome" in d:
    print("Presente!")
\end{lstlisting}

\subsection*{Iterazione su dizionari}
\begin{lstlisting}
# Solo chiavi
for chiave in d:
    print(chiave)

# Chiavi e valori
for chiave, valore in d.items():
    print(chiave, valore)

# Solo valori
for valore in d.values():
    print(valore)
\end{lstlisting}

\subsection*{Metodi principali dei dizionari}
\begin{multicols}{2}
\begin{itemize}
    \item \texttt{d.keys()}           % tutte le chiavi
    \item \texttt{d.values()}         % tutti i valori
    \item \texttt{d.items()}          % tutte le coppie (chiave, valore)
    \item \texttt{d.get(k, default)}  % valore di k, o default
    \item \texttt{d.pop(k, default)}  % rimuove e restituisce valore di k
    \item \texttt{d.popitem()}        % rimuove/rest. ultima coppia
    \item \texttt{d.clear()}          % svuota il dizionario
    \item \texttt{d.update(other)}    % aggiorna con altro dict
    \item \texttt{d.setdefault(k, default)} % valore di k, o lo crea
    \item \texttt{d.copy()}           % copia superficiale
\end{itemize}
\end{multicols}

\subsection*{Comprensione dei dizionari (dict comprehension)}
Modo compatto per creare dizionari:
\begin{lstlisting}
quadrati = {x: x**2 for x in range(5)}
# {0:0, 1:1, 2:4, 3:9, 4:16}
pari = {x: "pari" for x in range(10) if x % 2 == 0}
\end{lstlisting}

\subsection*{Dizionari annidati}
I valori possono essere altri dizionari:
\begin{lstlisting}
studenti = {
    "Anna": {"eta": 20, "corso": "Informatica"},
    "Luca": {"eta": 22, "corso": "Fisica"}
}
print(studenti["Anna"]["corso"])  # Informatica
\end{lstlisting}

\subsection*{Copia di dizionari}
\begin{lstlisting}
a = {"x": 1}
b = a              # alias, non copia!
c = a.copy()       # copia superficiale
import copy
d = copy.deepcopy(a)  # copia profonda (per dizionari annidati)
\end{lstlisting}

\subsection*{Mutabilità e aliasing}
Modificare un dizionario tramite un alias modifica anche l'originale.

\subsection*{Chiavi ammesse}
Le chiavi devono essere \textbf{immutabili} e \textbf{hashable}:
\begin{itemize}
    \item Ammesse: stringhe, numeri, tuple di oggetti immutabili, frozenset.
    \item Non ammesse: liste, set, dizionari, oggetti mutabili.
\end{itemize}
\begin{lstlisting}
d = {(1, 2): "a"}   # OK
# d = {[1, 2]: "b"} # Errore: lista non hashable
\end{lstlisting}

\subsection*{Valori ammissibili}
I valori possono essere di qualsiasi tipo, anche mutabili o altri dizionari.

\subsection*{Ordinamento dei dizionari}
Da Python 3.7+ i dizionari mantengono l'ordine di inserimento. Per ordinare un dizionario per chiave o valore:
\begin{lstlisting}
d = {"b": 2, "a": 1, "c": 3}
ordinato = dict(sorted(d.items()))  # Ordina per chiave
ordinato_val = dict(sorted(d.items(), key=lambda x: x[1]))
# Per valore
\end{lstlisting}

\subsection*{Unione e aggiornamento di dizionari}
\begin{lstlisting}
d1 = {"a": 1, "b": 2}
d2 = {"b": 3, "c": 4}
d1.update(d2)  # d1 = {"a": 1, "b": 3, "c": 4}

# Da Python 3.9+
d3 = d1 | d2   # Unione (nuovo dict)
\end{lstlisting}

\subsection*{Funzioni built-in utili}
\begin{itemize}
    \item \texttt{len(d)}: numero di coppie
    \item \texttt{list(d)}: lista delle chiavi
    \item \texttt{sorted(d)}: lista delle chiavi ordinate
    \item \texttt{min(d)}, \texttt{max(d)}: chiave minima/massima
    \item \texttt{sum(d.values())}: somma dei valori (se numerici)
\end{itemize}

\subsection*{Uso pratico dei dizionari}
\begin{itemize}
    \item Rappresentare dati strutturati (es. record, oggetti, JSON)
    \item Contare frequenze (\texttt{Counter})
    \item Lookup rapido di valori tramite chiave
    \item Rappresentare grafi, tabelle di configurazione, mapping
\end{itemize}

\subsection*{Moduli avanzati: collections.defaultdict e Counter}
\begin{lstlisting}
from collections import defaultdict, Counter

# defaultdict: valore di default per chiavi mancanti
d = defaultdict(int)
d["a"] += 1  # d["a"] = 1

# Counter: conteggio frequenze
c = Counter("banana")
print(c)  # Counter({'a': 3, 'b': 1, 'n': 2})
\end{lstlisting}

\subsection*{Metodi avanzati}
\begin{itemize}
    \item \texttt{setdefault(k, default)}: restituisce il valore di k, se non esiste lo crea con default.
    \item \texttt{fromkeys(seq, value=None)}: crea un nuovo dict con chiavi da seq e valore uguale per tutte.
\end{itemize}
\begin{lstlisting}
d = dict.fromkeys(["a", "b", "c"], 0)  #{'a': 0,'b': 0,'c': 0}
\end{lstlisting}

\subsection*{Dizionari e JSON}
I dizionari sono la struttura dati Python più simile agli oggetti JSON. Puoi convertire facilmente tra dict e JSON:
\begin{lstlisting}
import json
d = {"nome": "Anna", "eta": 20}
s = json.dumps(d)           # dict -> stringa JSON
d2 = json.loads(s)          # stringa JSON -> dict
\end{lstlisting}

\subsection*{Dizionari e unpacking}
Da Python 3.5+ puoi unire dizionari con l'unpacking:
\begin{lstlisting}
d1 = {"a": 1}
d2 = {"b": 2}
d3 = {**d1, **d2}  # {'a': 1, 'b': 2}
\end{lstlisting}

\subsection*{Dizionari e funzioni}
Puoi passare un dizionario come argomenti a una funzione usando \texttt{**}:
\begin{lstlisting}
def f(x, y):
    return x + y

d = {"x": 1, "y": 2}
print(f(**d))  # 3
\end{lstlisting}

\subsection*{Dizionari e oggetti personalizzati}
Le chiavi possono essere oggetti personalizzati, purché siano hashable (implementino \texttt{\_\_hash\_\_} e \texttt{\_\_eq\_\_}).

\subsection*{Limitazioni e attenzioni}
\begin{itemize}
    \item Le chiavi devono essere hashable (immutabili).
    \item L'ordine è garantito solo da Python 3.7+.
    \item Non puoi avere chiavi duplicate.
    \item L'accesso tramite chiave inesistente genera \texttt{KeyError} (usa \texttt{get()} o \texttt{defaultdict}).
\end{itemize}

\subsection*{Performance}
\begin{itemize}
    \item L'accesso, inserimento e rimozione tramite chiave sono molto veloci (O(1) in media).
    \item L'iterazione su chiavi, valori o coppie è efficiente.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Conta frequenze di parole in una frase
frase = "il gatto e il cane"
conta = {}
for parola in frase.split():
    conta[parola] = conta.get(parola, 0) + 1

# Invertire chiavi e valori
d = {"a": 1, "b": 2}
inverso = {v: k for k, v in d.items()}

# Dizionario da due liste
chiavi = ["x", "y"]
valori = [10, 20]
d = dict(zip(chiavi, valori))
\end{lstlisting}

\subsection*{Conclusioni}
I dizionari sono fondamentali in Python per rappresentare dati strutturati, eseguire lookup rapidi, contare frequenze, gestire configurazioni e molto altro. La loro conoscenza approfondita è essenziale per scrivere codice Python efficace, leggibile e performante.

\section{Funzioni}
Le \textbf{funzioni} in Python sono blocchi di codice riutilizzabili che eseguono un compito specifico. Permettono di organizzare il codice, evitare ripetizioni, migliorare la leggibilità e facilitare la manutenzione. Le funzioni possono ricevere dati in ingresso (argomenti), restituire valori in uscita (valori di ritorno) e possono essere definite sia dall’utente sia essere già presenti nel linguaggio (funzioni built-in).

\subsection*{Definizione di una funzione}
Per definire una funzione si usa la parola chiave \texttt{def}, seguita dal nome della funzione, parentesi tonde (che possono contenere parametri) e i due punti. Il corpo della funzione va indentato.

\begin{lstlisting}
def saluta():
    print("Ciao!")
\end{lstlisting}

\subsection*{Chiamata di una funzione}
Per eseguire una funzione basta scrivere il suo nome seguito da parentesi:

\begin{lstlisting}
saluta()  # Output: Ciao!
\end{lstlisting}

\subsection*{Parametri e argomenti}
Le funzioni possono accettare uno o più parametri (variabili che ricevono i valori passati dall’esterno):

\begin{lstlisting}
def somma(a, b):
    return a + b

risultato = somma(3, 5)  # 8
\end{lstlisting}

\textbf{Parametri} sono le variabili nella definizione della funzione. \textbf{Argomenti} sono i valori passati quando la funzione viene chiamata.

\subsection*{Valore di ritorno (\texttt{return})}
La parola chiave \texttt{return} serve per restituire un valore dalla funzione:

\begin{lstlisting}
def quadrato(x):
    return x * x

print(quadrato(4))  # 16
\end{lstlisting}

Se non viene specificato \texttt{return}, la funzione restituisce \texttt{None}.

\subsection*{Funzioni senza parametri e senza valore di ritorno}
\begin{lstlisting}
def stampa_benvenuto():
    print("Benvenuto!")

stampa_benvenuto()
\end{lstlisting}

\subsection*{Parametri opzionali (default)}
Puoi assegnare un valore di default ai parametri:

\begin{lstlisting}
def saluta(nome="Mondo"):
    print(f"Ciao, {nome}!")

saluta()         # Ciao, Mondo!
saluta("Anna")   # Ciao, Anna!
\end{lstlisting}

\subsection*{Argomenti posizionali e nominati}
Gli argomenti possono essere passati per posizione o per nome:

\begin{lstlisting}
def descrivi_persona(nome, eta):
    print(f"{nome} ha {eta} anni.")

descrivi_persona("Luca", 30)           # Posizionali
descrivi_persona(eta=25, nome="Anna")  # Nominati
\end{lstlisting}

\subsection*{Argomenti variabili: \texttt{*args} e \texttt{**kwargs}}
\texttt{*args} permette di passare un numero variabile di argomenti posizionali (come tupla):

\begin{lstlisting}
def somma_tutti(*numeri):
    return sum(numeri)

print(somma_tutti(1, 2, 3))  # 6
\end{lstlisting}

\texttt{**kwargs} permette di passare un numero variabile di argomenti nominati (come dizionario):

\begin{lstlisting}
def stampa_info(**info):
    for chiave, valore in info.items():
        print(f"{chiave}: {valore}")

stampa_info(nome="Anna", eta=22)
# nome: Anna
# eta: 22
\end{lstlisting}

\subsection*{Ordine dei parametri}
L’ordine corretto nella definizione è:
\begin{lstlisting}
def funzione(parametri_posizionali, parametri_default, *args, parametri_keyword_only, **kwargs):
    pass
\end{lstlisting}

\subsection*{Unpacking di argomenti}
Puoi “spacchettare” una lista/tupla o un dizionario come argomenti:

\begin{lstlisting}
def f(a, b, c):
    print(a, b, c)

t = (1, 2, 3)
f(*t)  # 1 2 3

d = {"a": 10, "b": 20, "c": 30}
f(**d)  # 10 20 30
\end{lstlisting}

\subsection*{Funzioni come oggetti di prima classe}
Le funzioni in Python sono oggetti: possono essere assegnate a variabili, passate come argomenti, restituite da altre funzioni.

\begin{lstlisting}
def saluta():
    print("Ciao!")

f = saluta
f()  # Ciao!
\end{lstlisting}

\subsection*{Funzioni annidate (nested functions)}
Puoi definire una funzione dentro un’altra:

\begin{lstlisting}
def esterna():
    def interna():
        print("Interna")
    interna()

esterna()  # Interna
\end{lstlisting}

\subsection*{Scope delle variabili (ambito)}
Le variabili definite all’interno di una funzione sono locali e non visibili all’esterno. Quelle definite fuori sono globali.

\begin{lstlisting}
x = 10  # globale

def funzione():
    y = 5  # locale
    print(x, y)

funzione()  # 10 5
# print(y)  # Errore: y non e' definita fuori dalla funzione
\end{lstlisting}

\subsection*{Parole chiave \texttt{global} e \texttt{nonlocal}}
\texttt{global} permette di modificare una variabile globale dall’interno di una funzione:

\begin{lstlisting}
x = 0

def incrementa():
    global x
    x += 1

incrementa()
print(x)  # 1
\end{lstlisting}

\texttt{nonlocal} permette di modificare una variabile non locale (ma non globale) in una funzione annidata:

\begin{lstlisting}
def esterna():
    x = 10
    def interna():
        nonlocal x
        x += 1
    interna()
    print(x)  # 11

esterna()
\end{lstlisting}

\subsection*{Documentazione delle funzioni (docstring)}
Puoi documentare una funzione con una stringa tra triple virgolette subito dopo la definizione:

\begin{lstlisting}
def somma(a, b):
    """Restituisce la somma di due numeri."""
    return a + b

print(somma.__doc__)  # Restituisce la somma di due numeri.
\end{lstlisting}

\subsection*{Annotazioni di tipo (type hints)}
Puoi specificare i tipi attesi per parametri e valore di ritorno (non obbligatorio):

\begin{lstlisting}
def somma(a: int, b: int) -> int:
    return a + b
\end{lstlisting}

\subsection*{Funzioni anonime (lambda)}
Le \texttt{lambda} sono funzioni senza nome, usate per operazioni semplici:

\begin{lstlisting}
doppio = lambda x: x * 2
print(doppio(5))  # 10

# Usate spesso con map, filter, sorted, ecc.
numeri = [1, 2, 3]
quadrati = list(map(lambda x: x**2, numeri))  # [1, 4, 9]
\end{lstlisting}

\subsection*{Funzioni built-in}
Python offre molte funzioni già pronte, come \texttt{len()}, \texttt{sum()}, \texttt{max()}, \texttt{min()}, \texttt{sorted()}, \texttt{print()}, \texttt{type()}, \texttt{range()}, ecc.

\begin{lstlisting}
print(len([1, 2, 3]))  # 3
print(sorted([3, 1, 2]))  # [1, 2, 3]
\end{lstlisting}

\subsection*{Funzioni ricorsive}
Una funzione può chiamare sé stessa (ricorsione):

\begin{lstlisting}
def fattoriale(n):
    if n == 0:
        return 1
    else:
        return n * fattoriale(n - 1)

print(fattoriale(5))  # 120
\end{lstlisting}

\subsection*{Funzioni generatori (\texttt{yield})}
Le funzioni che usano \texttt{yield} restituiscono un generatore, cioè una sequenza di valori calcolati “al volo”:

\begin{lstlisting}
def conta_fino_a(n):
    for i in range(1, n+1):
        yield i

for x in conta_fino_a(3):
    print(x)
# 1
# 2
# 3
\end{lstlisting}

\subsection*{Funzioni come parametri e valori di ritorno}
\begin{lstlisting}
def applica(funzione, valore):
    return funzione(valore)

def triplica(x):
    return x * 3

print(applica(triplica, 4))  # 12
\end{lstlisting}

\subsection*{Decoratori}
I decoratori sono funzioni che modificano il comportamento di altre funzioni:

\begin{lstlisting}
def decoratore(f):
    def wrapper(*args, **kwargs):
        print("Prima")
        risultato = f(*args, **kwargs)
        print("Dopo")
        return risultato
    return wrapper

@decoratore
def saluta():
    print("Ciao!")

saluta()
# Prima
# Ciao!
# Dopo
\end{lstlisting}

\subsection*{Funzioni built-in avanzate: map, filter, reduce, zip, enumerate}
\begin{lstlisting}
# map: applica una funzione a tutti gli elementi
numeri = [1, 2, 3]
doppio = list(map(lambda x: x*2, numeri))  # [2, 4, 6]

# filter: filtra elementi secondo una condizione
pari = list(filter(lambda x: x % 2 == 0, numeri))  # [2]

# reduce: riduce una sequenza a un singolo valore
from functools import reduce
somma = reduce(lambda x, y: x + y, numeri)  # 6

# zip: combina piu' sequenze
a = [1, 2]
b = ['a', 'b']
z = list(zip(a, b))  # [(1, 'a'), (2, 'b')]

# enumerate: restituisce coppie (indice, valore)
for i, val in enumerate(['x', 'y']):
    print(i, val)
\end{lstlisting}

\subsection*{Funzioni variadiche e keyword-only}
\textbf{Variadiche:} accettano un numero arbitrario di argomenti (\texttt{*args}, \texttt{**kwargs}).

\textbf{Keyword-only:} parametri che possono essere passati solo per nome (dopo \texttt{*}).

\begin{lstlisting}
def f(a, b, *, c=0):
    print(a, b, c)

f(1, 2, c=3)  # OK
# f(1, 2, 3)  # Errore
\end{lstlisting}

\subsection*{Funzioni e scope LEGB}
Python cerca le variabili in questo ordine:
\begin{itemize}
    \item \textbf{L}ocal: variabili locali alla funzione
    \item \textbf{E}nclosing: scope delle funzioni esterne (per funzioni annidate)
    \item \textbf{G}lobal: variabili globali del modulo
    \item \textbf{B}uilt-in: nomi predefiniti di Python
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Funzione che restituisce piu' valori
def min_max(lista):
    return min(lista), max(lista)

mn, mx = min_max([1, 5, 3])
print(mn, mx)  # 1 5

# Funzione che modifica una lista (mutabilita')
def aggiungi_elemento(l, x):
    l.append(x)

a = [1, 2]
aggiungi_elemento(a, 3)
print(a)  # [1, 2, 3]
\end{lstlisting}

\subsection*{Conclusioni}
Le funzioni sono fondamentali per strutturare, riutilizzare e organizzare il codice Python. Permettono di scrivere programmi modulari, leggibili e manutenibili. La conoscenza approfondita delle funzioni (parametri, scope, decoratori, generatori, lambda, ecc.) è essenziale per una programmazione Python efficace e professionale.

Le \textbf{classi} e gli \textbf{oggetti} sono i concetti fondamentali della programmazione orientata agli oggetti (OOP, Object-Oriented Programming) in Python. Permettono di modellare dati e comportamenti in modo strutturato, riutilizzabile e modulare.

\subsection*{Cos'è una classe?}
Una \textbf{classe} è un "modello" o "prototipo" che definisce le proprietà (attributi) e i comportamenti (metodi) che gli oggetti di quel tipo avranno. Puoi pensare a una classe come a un "progetto" o "stampo" per creare oggetti.

\subsection*{Cos'è un oggetto?}
Un \textbf{oggetto} è un'istanza concreta di una classe. Ogni oggetto ha i propri dati (attributi) e può eseguire azioni (metodi) definite dalla classe.

\subsection*{Definizione di una classe}
Per definire una classe si usa la parola chiave \texttt{class}:

\begin{lstlisting}
class Persona:
    pass  # classe vuota
\end{lstlisting}

\subsection*{Costruttore: \_\_init\_\_}
Il metodo speciale \texttt{\_\_init\_\_} è il costruttore: viene chiamato automaticamente quando si crea un nuovo oggetto. Serve per inizializzare gli attributi dell'oggetto.

\begin{lstlisting}
class Persona:
    def __init__(self, nome, eta):
        self.nome = nome
        self.eta = eta
\end{lstlisting}

\texttt{self} è il riferimento all'istanza corrente (obbligatorio come primo parametro nei metodi di istanza).

\subsection*{Creazione di oggetti (istanze)}
\begin{lstlisting}
p1 = Persona("Anna", 25)
p2 = Persona("Luca", 30)
print(p1.nome, p1.eta)  # Anna 25
\end{lstlisting}

\subsection*{Attributi di istanza e di classe}
\begin{itemize}
    \item \textbf{Attributi di istanza}: specifici per ogni oggetto (\texttt{self.nome})
    \item \textbf{Attributi di classe}: condivisi da tutte le istanze
\end{itemize}

\begin{lstlisting}
class Persona:
    specie = "Homo sapiens"  # attributo di classe
    def __init__(self, nome):
        self.nome = nome

print(Persona.specie)  # Homo sapiens
p = Persona("Anna")
print(p.specie)        # Homo sapiens
\end{lstlisting}

\subsection*{Metodi di istanza, di classe e statici}
\begin{itemize}
    \item \textbf{Metodi di istanza}: ricevono \texttt{self} (l'oggetto)
    \item \textbf{Metodi di classe}: ricevono \texttt{cls} (la classe), decorati con \texttt{@classmethod}
    \item \textbf{Metodi statici}: non ricevono né \texttt{self} né \texttt{cls}, decorati con \texttt{@staticmethod}
\end{itemize}

\begin{lstlisting}
class Persona:
    popolazione = 0

    def __init__(self, nome):
        self.nome = nome
        Persona.popolazione += 1

    def saluta(self):
        print(f"Ciao, sono {self.nome}")

    @classmethod
    def quante(cls):
        print(f"Popolazione: {cls.popolazione}")

    @staticmethod
    def specie():
        return "Homo sapiens"
\end{lstlisting}

\subsection*{Incapsulamento e visibilità}
In Python non esistono modificatori di accesso veri e propri (come \texttt{private}, \texttt{protected}, \texttt{public}), ma si usano convenzioni:
\begin{itemize}
    \item \texttt{\_attributo}: convenzione per "protetto" (uso interno)
    \item \texttt{\_\_attributo}: name mangling, difficile da accedere dall'esterno
\end{itemize}

\begin{lstlisting}
class Persona:
    def __init__(self, nome):
        self._nome = nome      # protetto
        self.__segreto = 123  # privato (name mangling)
\end{lstlisting}

\subsection*{Proprietà (property) e getter/setter}
Per controllare l'accesso agli attributi si usano le \texttt{property}:

\begin{lstlisting}
class Persona:
    def __init__(self, nome):
        self._nome = nome

    @property
    def nome(self):
        return self._nome

    @nome.setter
    def nome(self, valore):
        if not valore:
            raise ValueError("Nome vuoto!")
        self._nome = valore
\end{lstlisting}

\subsection*{Metodi speciali (dunder methods)}
I metodi che iniziano e finiscono con doppio underscore (\_\_) sono "speciali" e permettono di personalizzare il comportamento degli oggetti:

\begin{itemize}
    \item \texttt{\_\_init\_\_}: costruttore
    \item \texttt{\_\_str\_\_}: rappresentazione stringa (print)
    \item \texttt{\_\_repr\_\_}: rappresentazione tecnica
    \item \texttt{\_\_eq\_\_}, \texttt{\_\_lt\_\_}, \texttt{\_\_gt\_\_}: operatori di confronto
    \item \texttt{\_\_len\_\_}, \texttt{\_\_getitem\_\_}, \texttt{\_\_setitem\_\_}: comportamento come sequenze
    \item \texttt{\_\_call\_\_}: oggetto chiamabile come funzione
    \item \texttt{\_\_del\_\_}: distruttore (chiamato alla cancellazione)
\end{itemize}

\begin{lstlisting}
class Persona:
    def __init__(self, nome):
        self.nome = nome

    def __str__(self):
        return f"Persona: {self.nome}"

    def __eq__(self, other):
        return self.nome == other.nome
\end{lstlisting}

\subsection*{Ereditarietà}
Una classe può ereditare da un'altra (classe base o superclasse):

\begin{lstlisting}
class Studente(Persona):
    def __init__(self, nome, matricola):
        super().__init__(nome)
        self.matricola = matricola
\end{lstlisting}

\texttt{super()} permette di chiamare metodi della superclasse.

\subsection*{Polimorfismo}
Oggetti di classi diverse possono essere trattati allo stesso modo se implementano gli stessi metodi:

\begin{lstlisting}
class Animale:
    def parla(self):
        pass

class Cane(Animale):
    def parla(self):
        print("Bau!")

class Gatto(Animale):
    def parla(self):
        print("Miao!")

def fai_parlare(animale):
    animale.parla()

fai_parlare(Cane())
fai_parlare(Gatto())
\end{lstlisting}

\subsection*{Ereditarietà multipla}
Una classe può ereditare da più classi:

\begin{lstlisting}
class A:
    pass

class B:
    pass

class C(A, B):
    pass
\end{lstlisting}

Python risolve i conflitti con il Method Resolution Order (MRO).

\subsection*{Classi astratte e interfacce}
Python non ha interfacce come Java, ma puoi definire classi astratte con il modulo \texttt{abc}:

\begin{lstlisting}
from abc import ABC, abstractmethod

class Animale(ABC):
    @abstractmethod
    def parla(self):
        pass
\end{lstlisting}

Non puoi istanziare una classe astratta finché non implementi tutti i metodi astratti.

\subsection*{Composizione}
Un oggetto può contenere altri oggetti come attributi (relazione "has-a"):

\begin{lstlisting}
class Motore:
    pass

class Auto:
    def __init__(self):
        self.motore = Motore()
\end{lstlisting}

\subsection*{Duck typing}
In Python conta ciò che un oggetto \textit{sa fare}, non la sua classe. Se un oggetto implementa i metodi richiesti, può essere usato (principio "se cammina come un'anatra...").

\subsection*{Classi annidate}
Puoi definire una classe dentro un'altra:

\begin{lstlisting}
class Esterna:
    class Interna:
        pass
\end{lstlisting}

\subsection*{Metaclassi}
Le metaclassi sono "classi di classi", permettono di personalizzare la creazione delle classi (avanzato):

\begin{lstlisting}
class MiaMeta(type):
    def __new__(cls, nome, basi, dct):
        return super().__new__(cls, nome, basi, dct)

class MiaClasse(metaclass=MiaMeta):
    pass
\end{lstlisting}

\subsection*{Slot}
Per ottimizzare la memoria puoi usare \texttt{\_\_slots\_\_}:

\begin{lstlisting}
class Persona:
    __slots__ = ['nome', 'eta']
    def __init__(self, nome, eta):
        self.nome = nome
        self.eta = eta
\end{lstlisting}

\subsection*{Operatori di confronto e ordinamento}
Puoi personalizzare gli operatori (\texttt{==}, \texttt{<}, \texttt{>}, ecc.) implementando i metodi speciali:

\begin{lstlisting}
class Punto:
    def __init__(self, x):
        self.x = x
    def __eq__(self, other):
        return self.x == other.x
    def __lt__(self, other):
        return self.x < other.x
\end{lstlisting}

\subsection*{Oggetti come funzioni: \_\_call\_\_}
Se implementi \texttt{\_\_call\_\_}, puoi "chiamare" l'oggetto come una funzione:

\begin{lstlisting}
class Moltiplicatore:
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        return self.n * x

m = Moltiplicatore(3)
print(m(5))  # 15
\end{lstlisting}

\subsection*{Oggetti iterabili e iteratori}
Per rendere un oggetto iterabile, implementa \texttt{\_\_iter\_\_} e \texttt{\_\_next\_\_}:

\begin{lstlisting}
class Contatore:
    def __init__(self, limite):
        self.limite = limite
        self.valore = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.valore < self.limite:
            self.valore += 1
            return self.valore
        else:
            raise StopIteration
\end{lstlisting}

\subsection*{Oggetti context manager (\_\_enter\_\_, \_\_exit\_\_)}
Per usare un oggetto con \texttt{with}, implementa:

\begin{lstlisting}
class FileManager:
    def __enter__(self):
        print("Apro risorsa")
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Chiudo risorsa")

with FileManager():
    print("Dentro il blocco")
\end{lstlisting}

\subsection*{Documentazione delle classi}
Puoi documentare una classe con una docstring:

\begin{lstlisting}
class Persona:
    """Rappresenta una persona con nome ed eta'."""
    pass

print(Persona.__doc__)
\end{lstlisting}

\subsection*{Classi e moduli}
Le classi possono essere definite in moduli e importate:

\begin{lstlisting}
# file persona.py
class Persona:
    pass

# file main.py
from persona import Persona
\end{lstlisting}

\subsection*{Esempio completo}
\begin{lstlisting}
class Persona:
    popolazione = 0

    def __init__(self, nome, eta):
        self.nome = nome
        self.eta = eta
        Persona.popolazione += 1

    def saluta(self):
        print(f"Ciao, sono {self.nome} e ho {self.eta} anni.")

    @classmethod
    def quante(cls):
        print(f"Popolazione: {cls.popolazione}")

    @staticmethod
    def specie():
        return "Homo sapiens"

p1 = Persona("Anna", 25)
p2 = Persona("Luca", 30)
p1.saluta()
Persona.quante()
print(Persona.specie())
\end{lstlisting}

\subsection*{Conclusioni}
Le classi e gli oggetti sono il cuore della programmazione orientata agli oggetti in Python. Permettono di modellare dati e comportamenti, favoriscono il riuso del codice, l'incapsulamento, l'astrazione e la modularità. La conoscenza approfondita di classi, oggetti, ereditarietà, polimorfismo, metodi speciali e property è fondamentale per scrivere codice Python robusto, scalabile e professionale.

\section{Ereditarietà}
L'\textbf{ereditarietà} è uno dei concetti fondamentali della programmazione orientata agli oggetti (OOP) e permette di creare una nuova classe (\textbf{classe derivata} o \textbf{sottoclasse}) che eredita attributi e metodi da un'altra classe (\textbf{classe base} o \textbf{superclasse}). In Python, l'ereditarietà consente di riutilizzare codice, estendere funzionalità e modellare relazioni gerarchiche tra oggetti.

\subsection*{Cos'è l'ereditarietà?}
L'ereditarietà permette a una classe di acquisire automaticamente tutte le proprietà (attributi) e i comportamenti (metodi) di un'altra classe. La classe derivata può:
\begin{itemize}
    \item Usare attributi e metodi della classe base senza ridefinirli.
    \item Ridefinire (override) metodi della classe base per modificarne il comportamento.
    \item Aggiungere nuovi attributi e metodi propri.
\end{itemize}

\subsection*{Sintassi dell'ereditarietà in Python}
Per dichiarare che una classe eredita da un'altra, si specifica la superclasse tra parentesi dopo il nome della sottoclasse:
\begin{lstlisting}
class Animale:
    def parla(self):
        print("L'animale fa un verso")

class Cane(Animale):
    pass

c = Cane()
c.parla()  # Output: L'animale fa un verso
\end{lstlisting}

\subsection*{Override dei metodi}
La sottoclasse può ridefinire un metodo della superclasse per modificarne il comportamento:
\begin{lstlisting}
class Cane(Animale):
    def parla(self):
        print("Bau!")
\end{lstlisting}
Ora, chiamando \texttt{parla()} su un oggetto \texttt{Cane}, verrà eseguito il metodo ridefinito.

\subsection*{Aggiunta di nuovi attributi e metodi}
La sottoclasse può avere attributi e metodi aggiuntivi:
\begin{lstlisting}
class Gatto(Animale):
    def miagola(self):
        print("Miao!")
\end{lstlisting}

\subsection*{Costruttore e super()}
Se la sottoclasse ha un proprio costruttore (\texttt{\_\_init\_\_}), può richiamare quello della superclasse con \texttt{super()}:
\begin{lstlisting}
class Animale:
    def __init__(self, nome):
        self.nome = nome

class Cane(Animale):
    def __init__(self, nome, razza):
        super().__init__(nome)
        self.razza = razza
\end{lstlisting}
\texttt{super()} è fondamentale per inizializzare correttamente la parte ereditata.

\subsection*{Ereditarietà multipla}
Python supporta l'ereditarietà multipla: una classe può ereditare da più classi base.
\begin{lstlisting}
class A:
    def metodo_a(self):
        print("A")

class B:
    def metodo_b(self):
        print("B")

class C(A, B):
    pass

c = C()
c.metodo_a()  # Output: A
c.metodo_b()  # Output: B
\end{lstlisting}

\subsubsection*{Method Resolution Order (MRO)}
Quando una classe eredita da più classi, Python segue un ordine preciso per risolvere i metodi: il \textbf{Method Resolution Order} (MRO). Puoi visualizzare l'MRO con:
\begin{lstlisting}
print(C.mro())
# oppure
help(C)
\end{lstlisting}
L'MRO segue l'algoritmo C3 linearization.

\subsection*{Ereditarietà e tipi di metodi}
\begin{itemize}
    \item \textbf{Metodi di istanza}: ereditati e possono essere ridefiniti.
    \item \textbf{Metodi di classe} (\texttt{@classmethod}): ereditati e possono essere ridefiniti.
    \item \textbf{Metodi statici} (\texttt{@staticmethod}): ereditati e possono essere ridefiniti.
\end{itemize}

\subsection*{Ereditarietà e attributi}
\begin{itemize}
    \item \textbf{Attributi di istanza}: ereditati se inizializzati dalla superclasse (tramite \verb|super().__init__()|).
    \item \textbf{Attributi di classe}: condivisi tra tutte le istanze e sottoclassi, ma possono essere ridefiniti nella sottoclasse.
\end{itemize}

\subsection*{Ereditarietà e funzioni built-in}
\begin{itemize}
    \item \texttt{isinstance(obj, Classe)}: verifica se \texttt{obj} è istanza di \texttt{Classe} o di una sua sottoclasse.
    \item \texttt{issubclass(Sottoclasse, Superclasse)}: verifica se una classe è sottoclasse di un'altra.
\end{itemize}
\begin{lstlisting}
print(isinstance(c, Animale))  # True
print(issubclass(Cane, Animale))  # True
\end{lstlisting}

\subsection*{Ereditarietà e polimorfismo}
Grazie all'ereditarietà, puoi trattare oggetti di sottoclassi come oggetti della superclasse:
\begin{lstlisting}
def fai_parlare(animale):
    animale.parla()

fai_parlare(Cane())
fai_parlare(Gatto())
\end{lstlisting}
Questo è il \textbf{polimorfismo}: oggetti diversi rispondono allo stesso metodo in modo diverso.

\subsection*{Classi astratte e metodi astratti}
Per forzare le sottoclassi a implementare certi metodi, si usano le \textbf{classi astratte} con il modulo \texttt{abc}:
\begin{lstlisting}
from abc import ABC, abstractmethod

class Animale(ABC):
    @abstractmethod
    def parla(self):
        pass

class Cane(Animale):
    def parla(self):
        print("Bau!")
\end{lstlisting}
Non puoi istanziare una classe astratta finché non implementi tutti i metodi astratti.

\subsection*{Ereditarietà e metodi speciali}
I metodi speciali (\texttt{\_\_str\_\_}, \texttt{\_\_eq\_\_}, ecc.) sono ereditati e possono essere ridefiniti per personalizzare il comportamento degli oggetti.

\subsection*{Ereditarietà e composizione}
L'ereditarietà modella una relazione "è un" (\textit{is-a}), mentre la composizione modella una relazione "ha un" (\textit{has-a}). Usa l'ereditarietà solo quando la relazione logica è appropriata.

\subsection*{Ereditarietà e protected/private}
In Python, gli attributi preceduti da \texttt{\_} sono considerati "protetti" (convenzione), mentre quelli con \texttt{\_\_} sono soggetti a name mangling e meno accessibili dalle sottoclassi.

\subsection*{Ereditarietà e costruttori multipli}
Se una sottoclasse non chiama \verb|super().__init__()|, gli attributi della superclasse non vengono inizializzati.

\subsection*{Ereditarietà multipla e diamond problem}
Se più classi base hanno un antenato comune, si può creare il \textbf{diamond problem}. Python lo risolve con l'MRO (C3 linearization).

\begin{lstlisting}
class A:
    def metodo(self):
        print("A")

class B(A):
    def metodo(self):
        print("B")

class C(A):
    def metodo(self):
        print("C")

class D(B, C):
    pass

d = D()
d.metodo()  # Output: B (segue l'MRO)
print(D.mro())  # [D, B, C, A, object]
\end{lstlisting}

\subsection*{Ereditarietà e built-in}
Puoi ereditare anche dalle classi built-in di Python (come \texttt{list}, \texttt{dict}, ecc.) per estenderne il comportamento:
\begin{lstlisting}
class MiaLista(list):
    def somma(self):
        return sum(self)

ml = MiaLista([1, 2, 3])
print(ml.somma())  # 6
\end{lstlisting}

\subsection*{Ereditarietà e metaclassi}
Le metaclassi permettono di personalizzare il comportamento dell'ereditarietà a livello di creazione delle classi (avanzato).

\subsection*{Ereditarietà e documentazione}
Le sottoclassi ereditano anche la docstring della superclasse, a meno che non venga ridefinita.

\subsection*{Ereditarietà e performance}
L'ereditarietà aggiunge un piccolo overhead nella risoluzione dei metodi, ma in generale è molto efficiente grazie all'MRO.

\subsection*{Ereditarietà e \_\_slots\_\_}
Se la superclasse definisce \texttt{\_\_slots\_\_}, la sottoclasse deve ridefinirli se vuole aggiungere nuovi attributi.

\subsection*{Ereditarietà e isinstance/issubclass}
\texttt{isinstance(obj, Classe)} e \texttt{issubclass(Sottoclasse, Superclasse)} funzionano anche con ereditarietà multipla e classi astratte.

\subsection*{Ereditarietà e override di attributi di classe}
Se una sottoclasse ridefinisce un attributo di classe, questo nasconde quello della superclasse solo nella sottoclasse.

\subsection*{Ereditarietà e metodi privati}
I metodi con doppio underscore (\texttt{\_\_metodo}) sono soggetti a name mangling e non sono direttamente accessibili dalle sottoclassi.

\subsection*{Ereditarietà e super() avanzato}
\texttt{super()} può essere usato anche per chiamare metodi diversi da \texttt{\_\_init\_\_}, e in presenza di ereditarietà multipla segue l'MRO.

\subsection*{Ereditarietà e cooperative multiple inheritance}
In presenza di ereditarietà multipla, è buona pratica usare sempre \texttt{super()} per garantire che tutti i costruttori delle classi base vengano chiamati secondo l'MRO.

\begin{lstlisting}
class Base:
    def __init__(self):
        print("Base")

class A(Base):
    def __init__(self):
        super().__init__()
        print("A")

class B(Base):
    def __init__(self):
        super().__init__()
        print("B")

class C(A, B):
    def __init__(self):
        super().__init__()
        print("C")

c = C()
# Output:
# Base
# B
# A
# C
\end{lstlisting}

\subsection*{Ereditarietà e classi built-in ABC}
Molte classi built-in di Python (come \texttt{collections.abc.Sequence}, \texttt{Mapping}, ecc.) sono pensate per essere ereditate e forniscono metodi astratti da implementare.

\subsection*{Ereditarietà e introspezione}
Puoi esplorare la gerarchia di ereditarietà con:
\begin{lstlisting}
print(obj.__class__.__bases__)  # tuple delle superclassi dirette
print(obj.__class__.mro())      # MRO completo
\end{lstlisting}

\subsection*{Ereditarietà e best practice}
\begin{itemize}
    \item Usa l'ereditarietà solo quando esiste una relazione logica "is-a".
    \item Preferisci la composizione quando la relazione è "has-a".
    \item Usa sempre \texttt{super()} in presenza di ereditarietà multipla.
    \item Documenta chiaramente la gerarchia e le responsabilità delle classi.
    \item Evita gerarchie troppo profonde o complesse.
\end{itemize}

\subsection*{Esempio pratico completo}
\begin{lstlisting}
from abc import ABC, abstractmethod

class Veicolo(ABC):
    def __init__(self, marca):
        self.marca = marca

    @abstractmethod
    def muovi(self):
        pass

class Auto(Veicolo):
    def muovi(self):
        print(f"L'auto {self.marca} si muove su strada.")

class Barca(Veicolo):
    def muovi(self):
        print(f"La barca {self.marca} naviga sull'acqua.")

class Anfibio(Auto, Barca):
    def muovi(self):
        print(f"L'anfibio {self.marca} si muove ovunque!")

v = Anfibio("Amphicar")
v.muovi()  # L'anfibio Amphicar si muove ovunque!
print(Anfibio.mro())
\end{lstlisting}

\subsection*{Conclusioni}
L'ereditarietà è uno strumento potente per la riusabilità, l'estensione e la modellazione delle relazioni tra oggetti. Permette di scrivere codice più modulare, mantenibile e scalabile. Tuttavia, va usata con attenzione per evitare gerarchie troppo complesse e per mantenere il codice leggibile e facilmente manutenibile. La comprensione approfondita dell'ereditarietà, dell'MRO, del polimorfismo e delle classi astratte è fondamentale per una programmazione Python avanzata e professionale.

\section{Scope delle variabili}
Lo \textbf{scope} (ambito) di una variabile in Python indica la porzione di codice in cui quella variabile è visibile e accessibile. Comprendere lo scope è fondamentale per evitare errori, bug e comportamenti inattesi nei programmi.

\subsection*{Tipi di scope in Python (LEGB Rule)}
Python segue la regola LEGB per la risoluzione dei nomi delle variabili:
\begin{itemize}
    \item \textbf{L}ocal: variabili definite all'interno di una funzione (scope locale).
    \item \textbf{E}nclosing: scope delle funzioni esterne (per funzioni annidate).
    \item \textbf{G}lobal: variabili definite a livello di modulo (fuori da funzioni/classi).
    \item \textbf{B}uilt-in: nomi predefiniti di Python (come \texttt{len}, \texttt{print}, ecc.).
\end{itemize}

\subsection*{Scope locale}
Una variabile definita dentro una funzione è locale a quella funzione e non è accessibile dall'esterno:
\begin{lstlisting}
def funzione():
    x = 10  # locale
    print(x)

funzione()  # 10
# print(x)  # Errore: x non e' definita fuori dalla funzione
\end{lstlisting}

\subsection*{Scope globale}
Una variabile definita fuori da tutte le funzioni è globale e accessibile ovunque nel modulo:
\begin{lstlisting}
x = 5  # globale

def stampa():
    print(x)  # accede alla variabile globale

stampa()  # 5
\end{lstlisting}

\subsection*{Scope enclosing (funzioni annidate)}
Quando una funzione è definita dentro un'altra, le variabili della funzione esterna sono visibili a quella interna (enclosing scope):
\begin{lstlisting}
def esterna():
    x = 20
    def interna():
        print(x)  # accede a x della funzione esterna
    interna()

esterna()  # 20
\end{lstlisting}

\subsection*{Scope built-in}
Python ha uno scope speciale per i nomi predefiniti:
\begin{lstlisting}
print(len([1, 2, 3]))  # print e len sono built-in
\end{lstlisting}

\subsection*{Regola di risoluzione dei nomi (LEGB)}
Quando accedi a una variabile, Python cerca nell'ordine:
\begin{enumerate}
    \item Scope locale (funzione corrente)
    \item Scope enclosing (funzioni esterne, se presenti)
    \item Scope globale (modulo)
    \item Scope built-in (nomi predefiniti)
\end{enumerate}

\subsection*{Modifica delle variabili globali: \texttt{global}}
Per modificare una variabile globale dentro una funzione, usa la parola chiave \texttt{global}:
\begin{lstlisting}
x = 0

def incrementa():
    global x
    x += 1

incrementa()
print(x)  # 1
\end{lstlisting}
Senza \texttt{global}, Python crea una nuova variabile locale con lo stesso nome.

\subsection*{Modifica delle variabili non locali: \texttt{nonlocal}}
Per modificare una variabile dello scope enclosing (non globale), usa \texttt{nonlocal}:
\begin{lstlisting}
def esterna():
    x = 10
    def interna():
        nonlocal x
        x += 1
    interna()
    print(x)  # 11

esterna()
\end{lstlisting}
\texttt{nonlocal} funziona solo nelle funzioni annidate.

\subsection*{Shadowing (oscuramento) delle variabili}
Se una variabile locale ha lo stesso nome di una globale, la locale "oscura" la globale nello scope della funzione:
\begin{lstlisting}
x = 100

def f():
    x = 5  # locale, oscura la globale
    print(x)

f()      # 5
print(x) # 100
\end{lstlisting}

\subsection*{Scope nelle classi}
Gli attributi delle classi e delle istanze hanno uno scope diverso:
\begin{lstlisting}
x = 1

class A:
    x = 2  # attributo di classe

    def metodo(self):
        x = 3  # locale al metodo
        print(x, self.x)

a = A()
a.metodo()  # 3 2
\end{lstlisting}

\subsection*{Scope nei cicli e nelle comprensioni}
Le variabili dei cicli \texttt{for} e delle comprensioni di lista/set/dict sono visibili nello scope in cui sono definite:
\begin{lstlisting}
for i in range(3):
    pass
print(i)  # 2 (l'ultimo valore)

# Dal Python 3, le variabili nelle comprensioni
#hanno uno scope separato:
x = 10
lst = [x for x in range(5)]
print(x)  # 10
\end{lstlisting}

\subsection*{Scope nei moduli}
Ogni modulo ha il proprio scope globale. Variabili globali in un modulo non sono visibili in altri moduli a meno che non vengano importate.

\subsection*{Scope e funzioni lambda}
Le lambda seguono le stesse regole di scope delle funzioni normali:
\begin{lstlisting}
def f():
    x = 10
    return lambda y: x + y

g = f()
print(g(5))  # 15
\end{lstlisting}

\subsection*{Esempio completo: LEGB}
\begin{lstlisting}
x = "globale"

def esterna():
    x = "enclosing"
    def interna():
        x = "locale"
        print(x)  # locale
    interna()
    print(x)      # enclosing

esterna()
print(x)          # globale
\end{lstlisting}

\subsection*{Best practice e attenzioni}
\begin{itemize}
    \item Evita di usare troppe variabili globali: rendono il codice difficile da mantenere.
    \item Usa \texttt{global} e \texttt{nonlocal} solo quando necessario.
    \item Preferisci passare variabili come argomenti alle funzioni.
    \item Fai attenzione allo shadowing: nomi uguali in scope diversi possono causare confusione.
    \item Ricorda che le variabili mutabili (liste, dict) possono essere modificate anche senza \texttt{global}, ma solo i loro contenuti, non il riferimento.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Modifica di una lista globale senza global
lista = []

def aggiungi(x):
    lista.append(x)  # OK: modifica il contenuto

aggiungi(5)
print(lista)  # [5]

# Ma per riassegnare serve global
def resetta():
    global lista
    lista = []

resetta()
print(lista)  # []
\end{lstlisting}

\subsection*{Conclusioni}
Lo scope delle variabili è fondamentale per la corretta gestione dei dati e per evitare errori di visibilità e modifica indesiderata. Comprendere la regola LEGB, l'uso di \texttt{global} e \texttt{nonlocal}, e le differenze tra scope locale, globale, enclosing e built-in è essenziale per scrivere codice Python robusto, leggibile e privo di bug.

\section{Moduli}
I \textbf{moduli} in Python sono file che contengono definizioni di variabili, funzioni, classi e istruzioni eseguibili. Permettono di organizzare il codice in unità riutilizzabili, facilitando la manutenzione, la leggibilità e la condivisione. I moduli sono la base della modularità in Python e consentono di suddividere programmi complessi in parti più semplici.

\subsection*{Cos'è un modulo?}
Un modulo è semplicemente un file con estensione \texttt{.py} che può essere importato in altri file Python. Il nome del modulo corrisponde al nome del file (senza estensione).

\begin{lstlisting}
# file: mio_modulo.py
def saluta(nome):
    print(f"Ciao, {nome}!")
\end{lstlisting}

\subsection*{Importazione di moduli}
Per usare un modulo, si utilizza la parola chiave \texttt{import}:

\begin{lstlisting}
import mio_modulo
mio_modulo.saluta("Anna")
\end{lstlisting}

Puoi importare solo alcune parti di un modulo:

\begin{lstlisting}
from mio_modulo import saluta
saluta("Luca")
\end{lstlisting}

Puoi anche rinominare il modulo o la funzione importata:

\begin{lstlisting}
import mio_modulo as mm
mm.saluta("Marco")

from mio_modulo import saluta as s
s("Giulia")
\end{lstlisting}

\subsection*{Dove cerca Python i moduli?}
Quando importi un modulo, Python cerca il file corrispondente nei percorsi elencati in \texttt{sys.path}:

\begin{itemize}
    \item La directory corrente (dove viene eseguito lo script)
    \item Le directory specificate nella variabile d'ambiente \texttt{PYTHONPATH}
    \item Le directory di installazione standard di Python (site-packages, ecc.)
\end{itemize}

Puoi vedere i percorsi con:

\begin{lstlisting}
import sys
print(sys.path)
\end{lstlisting}

\subsection*{Tipi di moduli}
\begin{itemize}
    \item \textbf{Moduli standard}: forniti con Python (es. \texttt{math}, \texttt{os}, \texttt{sys}, \texttt{random}, ecc.)
    \item \textbf{Moduli di terze parti}: installabili tramite \texttt{pip} (es. \texttt{numpy}, \texttt{pandas}, \texttt{requests}, ecc.)
    \item \textbf{Moduli personalizzati}: creati dall'utente (file \texttt{.py})
    \item \textbf{Moduli built-in}: scritti in C e integrati nell'interprete (es. \texttt{sys}, \texttt{time})
\end{itemize}

\subsection*{Importazione di tutto il contenuto}
\begin{lstlisting}
from mio_modulo import *
saluta("Mario")
\end{lstlisting}
\textbf{Nota:} Non è consigliato usare \texttt{*} perché può causare conflitti di nomi e rende il codice meno leggibile.

\subsection*{Il file \_\_init\_\_.py e i package}
Un \textbf{package} è una cartella che contiene un insieme di moduli e un file speciale \texttt{\_\_init\_\_.py} (può essere vuoto). Questo file indica a Python che la cartella è un package.

\begin{verbatim}
mio_package/
    __init__.py
    modulo1.py
    modulo2.py
\end{verbatim}

Importazione:

\begin{lstlisting}
import mio_package.modulo1
from mio_package import modulo2
\end{lstlisting}

\subsection*{Struttura dei package annidati}
I package possono essere annidati:

\begin{verbatim}
mio_package/
    __init__.py
    subpackage/
        __init__.py
        modulo3.py
\end{verbatim}

Importazione:

\begin{lstlisting}
from mio_package.subpackage import modulo3
\end{lstlisting}

\subsection*{Import relativi e assoluti}
\begin{itemize}
    \item \textbf{Import assoluto}: dal root del progetto/package
    \item \textbf{Import relativo}: usa il punto \texttt{.} per riferirsi al package corrente o ai parent
\end{itemize}

\begin{lstlisting}
# In mio_package/modulo1.py
from . import modulo2      # import relativo
from .. import altro_modulo # dal package padre
\end{lstlisting}

\subsection*{Il modulo \_\_main\_\_}
Quando un modulo viene eseguito direttamente, la variabile speciale \texttt{\_\_name\_\_} vale \texttt{"\_\_main\_\_"}. Quando viene importato, vale il nome del modulo.

\begin{lstlisting}
# file: mio_modulo.py
def saluta():
    print("Ciao!")

if __name__ == "__main__":
    saluta()
\end{lstlisting}

Questo permette di scrivere codice che viene eseguito solo se il file è eseguito direttamente, non quando è importato.

\subsection*{Variabili speciali dei moduli}
\begin{itemize}
    \item \texttt{\_\_name\_\_}: nome del modulo
    \item \texttt{\_\_file\_\_}: percorso del file del modulo
    \item \texttt{\_\_package\_\_}: nome del package
    \item \texttt{\_\_doc\_\_}: docstring del modulo
    \item \texttt{\_\_path\_\_}: solo per package, lista dei percorsi
\end{itemize}

\subsection*{Ricaricare un modulo}
Se modifichi un modulo durante una sessione interattiva, puoi ricaricarlo con:

\begin{lstlisting}
import importlib
import mio_modulo
importlib.reload(mio_modulo)
\end{lstlisting}

\subsection*{Moduli compilati e cache (\_\_pycache\_\_)}
Quando importi un modulo, Python lo compila in bytecode (\texttt{.pyc}) e lo salva nella cartella \texttt{\_\_pycache\_\_} per velocizzare i successivi import.

\subsection*{Moduli built-in}
Alcuni moduli sono integrati nell'interprete e non hanno un file \texttt{.py} (es. \texttt{sys}, \texttt{math}, \texttt{time}). Puoi vedere la lista con:

\begin{lstlisting}
import sys
print(sys.builtin_module_names)
\end{lstlisting}

\subsection*{Installazione di moduli di terze parti}
Usa \texttt{pip} per installare moduli esterni:

\begin{verbatim}
pip install nome_modulo
\end{verbatim}

\subsection*{Documentazione dei moduli}
Puoi documentare un modulo con una docstring all'inizio del file:

\begin{lstlisting}
"""Questo modulo contiene funzioni di esempio."""
def saluta():
    pass
\end{lstlisting}

\subsection*{Esportare solo alcune parti: \_\_all\_\_}
Nel modulo puoi definire la lista \texttt{\_\_all\_\_} per specificare cosa viene importato con \texttt{from modulo import *}:

\begin{lstlisting}
__all__ = ["saluta", "addio"]
\end{lstlisting}

\subsection*{Organizzazione di un progetto Python}
Un progetto Python ben strutturato usa moduli e package per separare logica, test, configurazione, ecc.

\begin{verbatim}
progetto/
    main.py
    modulo1.py
    utils/
        __init__.py
        helper.py
    tests/
        test_modulo1.py
\end{verbatim}

\subsection*{Moduli e namespace}
Ogni modulo ha il proprio namespace: variabili, funzioni e classi definite in un modulo non sono visibili in altri moduli a meno che non vengano importate.

\subsection*{Moduli e import ciclici}
Se due moduli si importano a vicenda, si crea un \textit{import ciclico} che può causare errori. È buona pratica evitare dipendenze circolari.

\subsection*{Moduli e script eseguibili}
Un modulo può essere sia importato che eseguito come script. Usa il controllo su \texttt{\_\_name\_\_} per distinguere i due casi.

\subsection*{Moduli e variabili globali}
Le variabili definite a livello di modulo sono globali solo all'interno di quel modulo.

\subsection*{Moduli e sys.modules}
Python mantiene una cache dei moduli già importati in \texttt{sys.modules}. Se importi più volte lo stesso modulo, viene eseguito solo la prima volta.

\subsection*{Moduli e introspezione}
Puoi esplorare il contenuto di un modulo con \texttt{dir()}:

\begin{lstlisting}
import math
print(dir(math))
\end{lstlisting}

\subsection*{Moduli e import dinamico}
Puoi importare moduli dinamicamente usando \texttt{importlib}:

\begin{lstlisting}
import importlib
modulo = importlib.import_module("math")
print(modulo.sqrt(16))
\end{lstlisting}

\subsection*{Moduli e distribuzione}
Per distribuire i tuoi moduli o package, puoi creare un pacchetto installabile (\texttt{setup.py}, \texttt{pyproject.toml}) e pubblicarlo su PyPI.

\subsection*{Moduli e virtual environment}
Per isolare le dipendenze dei moduli di terze parti, usa ambienti virtuali (\texttt{venv}, \texttt{virtualenv}).

\subsection*{Esempio pratico di modulo}
\begin{lstlisting}
# file: calcoli.py
"""Modulo di esempio per operazioni matematiche."""

def somma(a, b):
    """Restituisce la somma di due numeri."""
    return a + b

def moltiplica(a, b):
    """Restituisce il prodotto di due numeri."""
    return a * b

if __name__ == "__main__":
    print(somma(2, 3))
    print(moltiplica(4, 5))
\end{lstlisting}

\subsection*{Esempio pratico di package}
\begin{verbatim}
mio_package/
    __init__.py
    aritmetica.py
    geometria.py
\end{verbatim}

\begin{lstlisting}
# aritmetica.py
def somma(a, b):
    return a + b

# geometria.py
def area_rettangolo(base, altezza):
    return base * altezza

# __init__.py
from .aritmetica import somma
from .geometria import area_rettangolo
\end{lstlisting}

\begin{lstlisting}
# main.py
from mio_package import somma, area_rettangolo
print(somma(1, 2))
print(area_rettangolo(3, 4))
\end{lstlisting}

\subsection*{Conclusioni}
I moduli sono fondamentali per la scrittura di codice Python organizzato, riutilizzabile e scalabile. Permettono di suddividere il programma in parti logiche, facilitano la collaborazione e la manutenzione, e sono la base per la creazione di librerie e applicazioni complesse. La conoscenza approfondita dei moduli, dei package, delle regole di importazione e delle best practice di organizzazione del codice è essenziale per ogni programmatore Python.

\section{Datetime}
La gestione di date e orari in Python è affidata principalmente al modulo \texttt{datetime}, che fa parte della libreria standard. Questo modulo permette di lavorare con date, orari, intervalli temporali, fusi orari e molto altro. Di seguito una panoramica completa delle funzionalità principali.

\subsection*{Importazione del modulo}
\begin{lstlisting}
import datetime
from datetime import date, time, datetime, timedelta, timezone
\end{lstlisting}

\subsection*{Classi principali di \texttt{datetime}}
\begin{itemize}
    \item \texttt{date}: rappresenta una data (anno, mese, giorno)
    \item \texttt{time}: rappresenta un orario (ora, minuti, secondi, microsecondi)
    \item \texttt{datetime}: rappresenta una data e un orario
    \item \texttt{timedelta}: rappresenta una differenza tra due date/ore (intervallo di tempo)
    \item \texttt{timezone}: rappresenta un fuso orario
\end{itemize}

\subsection*{Classe \texttt{date}}
\begin{lstlisting}
d = datetime.date(2024, 6, 1)
print(d)  # 2024-06-01

oggi = datetime.date.today()
print(oggi)  # data odierna

# Attributi
print(d.year, d.month, d.day)

# Metodi
d2 = d.replace(year=2025)
print(d2)
\end{lstlisting}

\subsection*{Classe \texttt{time}}
\begin{lstlisting}
t = datetime.time(14, 30, 15, 123456)
print(t)  # 14:30:15.123456

# Attributi
print(t.hour, t.minute, t.second, t.microsecond)
\end{lstlisting}

\subsection*{Classe \texttt{datetime}}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
dt = datetime.datetime(2024, 6, 1, 14, 30, 0)
print(dt)  # 2024-06-01 14:30:00

adesso = datetime.datetime.now()
print(adesso)  # data e ora attuali

utcnow = datetime.datetime.utcnow()
print(utcnow)  # data e ora UTC

# Attributi
print(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)

# Metodi
dt2 = dt.replace(year=2025, hour=10)
print(dt2)
\end{lstlisting}

\subsection*{Classe \texttt{timedelta}}
\begin{lstlisting}
delta = datetime.timedelta(days=5, hours=3, minutes=10)
print(delta)  # 5 days, 3:10:00

# Operazioni con timedelta
dopo = dt + delta
prima = dt - delta
print(dopo, prima)

# Differenza tra due date/datetime
diff = dt - datetime.datetime(2024, 5, 1)
print(diff.days, diff.total_seconds())
\end{lstlisting}

\subsection*{Fusi orari (\texttt{timezone})}
\begin{lstlisting}
from datetime import timezone, timedelta

# UTC
dt_utc = datetime.datetime.now(timezone.utc)
print(dt_utc)

# Fuso orario personalizzato (es. Italia, UTC+2)
tz = timezone(timedelta(hours=2))
dt_tz = datetime.datetime.now(tz)
print(dt_tz)
\end{lstlisting}

\subsection*{Conversione tra fusi orari}
\begin{lstlisting}
dt = datetime.datetime(2024, 6, 1, 12, 0, tzinfo=timezone.utc)
dt_italia = dt.astimezone(timezone(timedelta(hours=2)))
print(dt_italia)
\end{lstlisting}

\subsection*{Parsing e formattazione di date e orari}
\textbf{Formattazione:}
\begin{lstlisting}
dt = datetime.datetime.now()
s = dt.strftime("%d/%m/%Y %H:%M:%S")
print(s)  # es: 01/06/2024 14:30:00
\end{lstlisting}

\textbf{Parsing:}
\begin{lstlisting}
s = "01/06/2024 14:30:00"
dt = datetime.datetime.strptime(s, "%d/%m/%Y %H:%M:%S")
print(dt)
\end{lstlisting}

\textbf{Codici di formattazione principali:}
\begin{itemize}
    \item \texttt{\%Y}: anno (es. 2024)
    \item \texttt{\%m}: mese (01-12)
    \item \texttt{\%d}: giorno (01-31)
    \item \texttt{\%H}: ora (00-23)
    \item \texttt{\%M}: minuti (00-59)
    \item \texttt{\%S}: secondi (00-59)
    \item \texttt{\%f}: microsecondi
    \item \texttt{\%A}: giorno della settimana (nome completo)
    \item \texttt{\%a}: giorno della settimana (abbreviato)
    \item \texttt{\%B}: mese (nome completo)
    \item \texttt{\%b}: mese (abbreviato)
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Calcolare l'eta'
nascita = datetime.date(2000, 1, 1)
oggi = datetime.date.today()
eta = oggi.year - nascita.year - (
    (oggi.month, oggi.day) < (nascita.month, nascita.day)
)
print(eta)

# Giorno della settimana
print(oggi.weekday())      # 0=lunedi', 6=domenica
print(oggi.isoweekday())   # 1=lunedi', 7=domenica

# Primo e ultimo giorno del mese
from calendar import monthrange
anno, mese = oggi.year, oggi.month
primo = datetime.date(anno, mese, 1)
ultimo = datetime.date(anno, mese, monthrange(anno, mese)[1])
print(primo, ultimo)
\end{lstlisting}

\subsection*{Gestione timestamp Unix}
\begin{lstlisting}
# Da datetime a timestamp
dt = datetime.datetime.now()
ts = dt.timestamp()
print(ts)

# Da timestamp a datetime
dt2 = datetime.datetime.fromtimestamp(ts)
print(dt2)
\end{lstlisting}

\subsection*{Date e orari ISO 8601}
\begin{lstlisting}
dt = datetime.datetime.now()
iso = dt.isoformat()
print(iso)  # es: 2024-06-01T14:30:00.123456

# Parsing da stringa ISO
dt2 = datetime.datetime.fromisoformat(iso)
print(dt2)
\end{lstlisting}

\subsection*{Date e orari in formato locale}
\begin{lstlisting}
import locale
locale.setlocale(locale.LC_TIME, "it_IT.UTF-8")
# Su sistemi compatibili
dt = datetime.datetime.now()
print(dt.strftime("%A %d %B %Y"))  # es: sabato 01 giugno 2024
\end{lstlisting}

\subsection*{Modulo \texttt{calendar}}
Il modulo \texttt{calendar} permette di lavorare con calendari, settimane, giorni del mese, ecc.
\begin{lstlisting}
import calendar
print(calendar.month(2024, 6))
print(calendar.isleap(2024))  # True se anno bisestile
\end{lstlisting}

\subsection*{Modulo \texttt{time}}
Il modulo \texttt{time} offre funzioni a basso livello per lavorare con il tempo (timestamp, sleep, ecc.):
\begin{lstlisting}
import time
print(time.time())  # timestamp corrente
time.sleep(2)       # pausa di 2 secondi
\end{lstlisting}

\subsection*{Gestione avanzata dei fusi orari}
Per una gestione avanzata dei fusi orari (es. ora legale, database IANA), si consiglia il modulo \texttt{zoneinfo} (da Python 3.9+) o librerie esterne come \texttt{pytz}:
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
from zoneinfo import ZoneInfo
dt = datetime.datetime(2024, 6, 1, 12, 0, tzinfo=ZoneInfo("Europe/Rome"))
print(dt)
\end{lstlisting}

\subsection*{Librerie esterne per date e orari}
\begin{itemize}
    \item \texttt{pytz}: gestione avanzata dei fusi orari (ora deprecato in favore di \texttt{zoneinfo})
    \item \texttt{dateutil}: parsing flessibile, ricorrenze, intervalli
    \item \texttt{arrow}, \texttt{pendulum}, \texttt{moment}: API più semplici e potenti per date e orari
\end{itemize}

\subsection*{Esempio con \texttt{dateutil}}
\begin{lstlisting}
from dateutil.parser import parse
dt = parse("1 giugno 2024 14:30", dayfirst=True)
print(dt)
\end{lstlisting}

\subsection*{Best practice e attenzioni}
\begin{itemize}
    \item Preferisci sempre oggetti \texttt{datetime} con fuso orario esplicito (\texttt{tzinfo}) per evitare ambiguità.
    \item Usa \texttt{timedelta} per calcoli temporali, non sommare direttamente giorni/ore/minuti.
    \item Per serializzare date e orari, usa formati standard come ISO 8601.
    \item Attenzione alle differenze tra ora locale e UTC.
    \item Per calcoli complessi su ricorrenze, festività, ecc., usa librerie esterne.
\end{itemize}

\subsection*{Riepilogo}
\begin{itemize}
    \item \texttt{datetime} è il modulo standard per gestire date e orari in Python.
    \item Offre classi per date, orari, intervalli, fusi orari e parsing/formatting.
    \item Supporta operazioni aritmetiche, confronto, conversione tra formati e fusi orari.
    \item Per esigenze avanzate, esistono librerie esterne come \texttt{dateutil}, \texttt{arrow}, \texttt{pendulum}.
\end{itemize}

\section{Classe Math}
La \textbf{classe} (in realtà \textbf{modulo}) \texttt{math} in Python fornisce funzioni matematiche standard, costanti e strumenti per lavorare con numeri reali (float). È parte della libreria standard di Python e va importato prima dell'uso.

\subsection*{Importazione del modulo}
\begin{lstlisting}
import math
\end{lstlisting}

\subsection*{Costanti principali}
\begin{itemize}
    \item \texttt{math.pi}: il valore di $\pi$ (3.141592...)
    \item \texttt{math.e}: il valore di $e$ (2.718281...)
    \item \texttt{math.tau}: il valore di $\tau$ ($2\pi$)
    \item \texttt{math.inf}: infinito positivo
    \item \texttt{math.nan}: valore "not a number"
\end{itemize}
\begin{lstlisting}
print(math.pi)    # 3.141592653589793
print(math.e)     # 2.718281828459045
print(math.tau)   # 6.283185307179586
print(math.inf)   # inf
print(math.nan)   # nan
\end{lstlisting}

\subsection*{Funzioni aritmetiche di base}
\begin{itemize}
    \item \texttt{math.ceil(x)}: arrotonda per eccesso (al prossimo intero)
    \item \texttt{math.floor(x)}: arrotonda per difetto (all'intero precedente)
    \item \texttt{math.trunc(x)}: tronca la parte decimale
    \item \texttt{math.fabs(x)}: valore assoluto (float)
    \item \texttt{math.copysign(x, y)}: valore di $x$ col segno di $y$
    \item \texttt{math.fmod(x, y)}: resto della divisione (float)
    \item \texttt{math.remainder(x, y)}: resto secondo la regola IEEE 754
    \item \texttt{math.modf(x)}: restituisce parte frazionaria e intera
\end{itemize}
\begin{lstlisting}
print(math.ceil(2.3))    # 3
print(math.floor(2.7))   # 2
print(math.trunc(-2.7))  # -2
print(math.fabs(-5))     # 5.0
print(math.copysign(3, -1)) # -3.0
print(math.fmod(7, 3))   # 1.0
print(math.modf(3.14))   # (0.14000000000000012, 3.0)
\end{lstlisting}

\subsection*{Radici, potenze e logaritmi}
\begin{itemize}
    \item \texttt{math.sqrt(x)}: radice quadrata
    \item \texttt{math.pow(x, y)}: $x^y$ (sempre float)
    \item \texttt{math.exp(x)}: $e^x$
    \item \texttt{math.expm1(x)}: $e^x - 1$ (preciso per $x$ vicino a 0)
    \item \texttt{math.log(x[, base])}: logaritmo (default base $e$)
    \item \texttt{math.log10(x)}: logaritmo in base 10
    \item \texttt{math.log2(x)}: logaritmo in base 2
    \item \texttt{math.log1p(x)}: $\log(1+x)$ (preciso per $x$ vicino a 0)
\end{itemize}
\begin{lstlisting}
print(math.sqrt(16))     # 4.0
print(math.pow(2, 5))    # 32.0
print(math.exp(2))       # 7.38905609893065
print(math.log(8, 2))    # 3.0
print(math.log10(100))   # 2.0
print(math.log2(32))     # 5.0
\end{lstlisting}

\subsection*{Funzioni trigonometriche}
\begin{itemize}
    \item \texttt{math.sin(x)}, \texttt{math.cos(x)}, \texttt{math.tan(x)}: seno, coseno, tangente (in radianti)
    \item \texttt{math.asin(x)}, \texttt{math.acos(x)}, \texttt{math.atan(x)}: arcotrigonometriche
    \item \texttt{math.atan2(y, x)}: arcotangente di $y/x$ (considera il quadrante)
    \item \texttt{math.hypot(x, y)}: $\sqrt{x^2 + y^2}$ (modulo vettore)
    \item \texttt{math.degrees(x)}: converte radianti in gradi
    \item \texttt{math.radians(x)}: converte gradi in radianti
\end{itemize}
\begin{lstlisting}
print(math.sin(math.pi/2))   # 1.0
print(math.cos(0))           # 1.0
print(math.tan(math.pi/4))   # 1.0
print(math.degrees(math.pi)) # 180.0
print(math.radians(180))     # 3.141592653589793
print(math.hypot(3, 4))      # 5.0
\end{lstlisting}

\subsection*{Funzioni iperboliche}
\begin{itemize}
    \item \texttt{math.sinh(x)}, \texttt{math.cosh(x)}, \texttt{math.tanh(x)}
    \item \texttt{math.asinh(x)}, \texttt{math.acosh(x)}, \texttt{math.atanh(x)}
\end{itemize}
\begin{lstlisting}
print(math.sinh(1))
print(math.cosh(0))
print(math.tanh(2))
\end{lstlisting}

\subsection*{Funzioni speciali}
\begin{itemize}
    \item \texttt{math.factorial(n)}: fattoriale di $n$ (solo interi $\geq 0$)
    \item \texttt{math.gamma(x)}: funzione gamma generalizzata
    \item \texttt{math.lgamma(x)}: logaritmo della funzione gamma
    \item \texttt{math.comb(n, k)}: combinazioni di $n$ su $k$
    \item \texttt{math.perm(n, k)}: permutazioni di $n$ su $k$
    \item \texttt{math.gcd(a, b)}: massimo comune divisore
    \item \texttt{math.lcm(a, b)}: minimo comune multiplo (da Python 3.9)
    \item \texttt{math.isqrt(n)}: radice intera di $n$
\end{itemize}
\begin{lstlisting}
print(math.factorial(5))   # 120
print(math.comb(5, 2))     # 10
print(math.perm(5, 2))     # 20
print(math.gcd(12, 18))    # 6
print(math.lcm(12, 18))    # 36
print(math.isqrt(10))      # 3
\end{lstlisting}

\subsection*{Funzioni di confronto e test}
\begin{itemize}
    \item \texttt{math.isfinite(x)}: True se $x$ è finito
    \item \texttt{math.isinf(x)}: True se $x$ è infinito
    \item \texttt{math.isnan(x)}: True se $x$ è NaN
    \item \texttt{math.isclose(a, b, rel\_tol=..., abs\_tol=...)}: True se $a$ e $b$ sono "vicini"
\end{itemize}
\begin{lstlisting}
print(math.isfinite(1e100))    # True
print(math.isinf(math.inf))    # True
print(math.isnan(math.nan))    # True
print(math.isclose(0.1+0.2, 0.3)) # True
\end{lstlisting}

\subsection*{Funzioni di arrotondamento avanzate}
\begin{itemize}
    \item \texttt{math.frexp(x)}: scompone $x$ in mantissa ed esponente
    \item \texttt{math.ldexp(m, e)}: $m \times 2^e$
    \item \texttt{math.nextafter(x, y)}: prossimo float dopo $x$ verso $y$
    \item \texttt{math.ulp(x)}: unità di ultimo posto (precisione macchina)
\end{itemize}
\begin{lstlisting}
print(math.frexp(8))      # (0.5, 4) perche' 8 = 0.5 * 2^4
print(math.ldexp(0.5, 4)) # 8.0
\end{lstlisting}

\subsection*{Funzioni di segno e manipolazione bit}
\begin{itemize}
    \item \texttt{math.copysign(x, y)}: valore di $x$ col segno di $y$
    \item \texttt{math.fsum(iterable)}: somma precisa di float
    \item \texttt{math.prod(iterable)}: prodotto di tutti gli elementi (da Python 3.8)
\end{itemize}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
print(math.fsum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])) # 1.0
print(math.prod([1, 2, 3, 4])) # 24
\end{lstlisting}

\subsection*{Funzioni per numeri complessi}
Per numeri complessi, usa il modulo \texttt{cmath}, non \texttt{math}.

\subsection*{Limitazioni del modulo math}
\begin{itemize}
    \item Lavora solo con numeri reali (float), non con complessi.
    \item Per funzioni statistiche, random, ecc., usa i moduli \texttt{statistics}, \texttt{random}, ecc.
    \item Per numeri complessi: \texttt{cmath}.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Calcolo area di un cerchio
r = 5
area = math.pi * r ** 2

# Calcolo distanza euclidea tra due punti
x1, y1 = 1, 2
x2, y2 = 4, 6
distanza = math.hypot(x2 - x1, y2 - y1)
\end{lstlisting}

\subsection*{Documentazione e approfondimenti}
Per la lista completa delle funzioni e costanti, consulta la documentazione ufficiale:
\url{https://docs.python.org/3/library/math.html}

\subsection*{Conclusioni}
Il modulo \texttt{math} è essenziale per calcoli matematici di base e avanzati in Python. Offre funzioni veloci, precise e ottimizzate per la maggior parte delle esigenze scientifiche, ingegneristiche e di calcolo numerico.

\section{Json}
Il modulo \textbf{json} in Python permette di lavorare con dati in formato JSON (JavaScript Object Notation), uno standard molto diffuso per lo scambio di dati tra applicazioni, servizi web, API e file di configurazione. JSON è un formato testuale, leggibile sia da umani che da macchine, e rappresenta strutture dati come oggetti (dizionari), array (liste), stringhe, numeri, booleani e null.

\subsection*{Importazione del modulo}
\begin{lstlisting}
import json
\end{lstlisting}

\subsection*{Funzionalità principali}
Il modulo \texttt{json} consente di:
\begin{itemize}
    \item Serializzare oggetti Python in stringhe JSON (\textbf{dumping})
    \item Deserializzare stringhe JSON in oggetti Python (\textbf{loading})
    \item Leggere e scrivere file JSON
    \item Personalizzare la serializzazione/deserializzazione
\end{itemize}

\subsection*{Conversione tra Python e JSON}
\textbf{Mappatura dei tipi:}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Python} & \textbf{JSON} \\
\hline
dict            & object \\
list, tuple     & array \\
str             & string \\
int, float      & number \\
True            & true \\
False           & false \\
None            & null \\
\hline
\end{tabular}
\end{center}

\subsection*{Serializzazione: da Python a JSON}
\begin{itemize}
    \item \texttt{json.dumps(obj, ...)}: converte un oggetto Python in una stringa JSON
    \item \texttt{json.dump(obj, file, ...)}: scrive un oggetto Python in un file come JSON
\end{itemize}
\begin{lstlisting}
dati = {"nome": "Anna", "eta": 25, "iscritta": True}
s = json.dumps(dati)
print(s)  # {"nome": "Anna", "eta": 25, "iscritta": true}

with open("dati.json", "w", encoding="utf-8") as f:
    json.dump(dati, f)
\end{lstlisting}

\subsection*{Deserializzazione: da JSON a Python}
\begin{itemize}
    \item \texttt{json.loads(s, ...)}: converte una stringa JSON in oggetto Python
    \item \texttt{json.load(file, ...)}: legge JSON da file e restituisce oggetto Python
\end{itemize}
\begin{lstlisting}
s = '{"nome": "Anna", "eta": 25, "iscritta": true}'
dati = json.loads(s)
print(dati["nome"])  # Anna

with open("dati.json", "r", encoding="utf-8") as f:
    dati = json.load(f)
\end{lstlisting}

\subsection*{Opzioni di serializzazione}
\begin{itemize}
    \item \texttt{indent}: aggiunge indentazione per una stampa leggibile
    \item \texttt{separators}: personalizza i separatori (default: (', ', ': '))
    \item \texttt{sort\_keys}: ordina le chiavi degli oggetti
    \item \texttt{ensure\_ascii}: True (default) esegue escape dei caratteri non ASCII, False mantiene UTF-8
\end{itemize}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
print(json.dumps(dati, indent=4, sort_keys=True, ensure_ascii=False))
\end{lstlisting}

\subsection*{Gestione di tipi non supportati}
Per serializzare tipi non standard (es. datetime, oggetti personalizzati), puoi:
\begin{itemize}
    \item Usare il parametro \texttt{default} in \texttt{dumps}/\texttt{dump}
    \item Implementare un encoder personalizzato
\end{itemize}
\begin{lstlisting}
import datetime

def encoder(obj):
    if isinstance(obj, datetime.datetime):
        return obj.isoformat()
    raise TypeError(f"Tipo non serializzabile: {type(obj)}")

dati = {"ora": datetime.datetime.now()}
print(json.dumps(dati, default=encoder))
\end{lstlisting}

\subsection*{Decodifica personalizzata}
Puoi personalizzare la decodifica con il parametro \texttt{object\_hook}:
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
def decoder(dct):
    if "ora" in dct:
        dct["ora"] = datetime.datetime.fromisoformat(dct["ora"])
    return dct

s = '{"ora": "2024-06-01T12:00:00"}'
dati = json.loads(s, object_hook=decoder)
\end{lstlisting}

\subsection*{Gestione degli errori}
\begin{itemize}
    \item \texttt{json.JSONDecodeError}: errore di parsing JSON
    \item \texttt{TypeError}: errore di serializzazione di tipo non supportato
\end{itemize}
\begin{lstlisting}
try:
    dati = json.loads("non e' json")
except json.JSONDecodeError as e:
    print("Errore di parsing:", e)
\end{lstlisting}

\subsection*{Lettura e scrittura di file JSON}
\begin{lstlisting}
# Scrittura
with open("file.json", "w", encoding="utf-8") as f:
    json.dump(dati, f, indent=2, ensure_ascii=False)

# Lettura
with open("file.json", "r", encoding="utf-8") as f:
    dati = json.load(f)
\end{lstlisting}

\subsection*{Parsing di JSON parziale (streaming)}
Per file molto grandi, puoi usare librerie esterne come \texttt{ijson} per il parsing incrementale.

\subsection*{Limiti e attenzioni}
\begin{itemize}
    \item Solo tipi base Python sono supportati nativamente (dict, list, str, int, float, bool, None)
    \item Le chiavi degli oggetti JSON devono essere stringhe
    \item I commenti non sono ammessi in JSON standard
    \item I numeri molto grandi possono perdere precisione
    \item Le tuple vengono convertite in array (list)
    \item Attenzione a serializzare oggetti mutabili/nidificati
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
# Convertire una lista di dizionari in JSON
utenti = [{"nome": "Anna"}, {"nome": "Luca"}]
s = json.dumps(utenti, indent=2)

# Caricare dati da una API REST
import requests
r = requests.get("https://jsonplaceholder.typicode.com/todos/1")
dati = r.json()  # oppure: json.loads(r.text)
\end{lstlisting}

\subsection*{Serializzazione avanzata: JSONEncoder e JSONDecoder}
Puoi estendere \texttt{json.JSONEncoder} per personalizzare la serializzazione:
\begin{lstlisting}
class MioEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        return super().default(obj)

json.dumps({"ora": datetime.datetime.now()}, cls=MioEncoder)
\end{lstlisting}

\subsection*{Compatibilità con altri linguaggi}
Il formato JSON prodotto da Python è compatibile con JavaScript, Java, Go, PHP, ecc.

\subsection*{Librerie esterne}
\begin{itemize}
    \item \texttt{ujson}: più veloce, ma meno compatibile
    \item \texttt{orjson}: molto veloce, supporta tipi avanzati
    \item \texttt{simplejson}: estende il modulo standard
\end{itemize}

\subsection*{Best practice}
\begin{itemize}
    \item Usa \texttt{indent} per file leggibili
    \item Usa \texttt{ensure\_ascii=False} per caratteri Unicode
    \item Gestisci gli errori di parsing
    \item Valida i dati dopo il caricamento
    \item Per dati complessi, serializza manualmente i tipi non standard
\end{itemize}

\subsection*{Documentazione ufficiale}
\url{https://docs.python.org/3/library/json.html}

\subsection*{Conclusioni}
Il modulo \texttt{json} è fondamentale per la serializzazione, la comunicazione tra servizi e la persistenza di dati strutturati in Python. La sua conoscenza è essenziale per lavorare con API, file di configurazione, web e applicazioni moderne.

\section{Pip}
Il comando \texttt{pip} è il gestore di pacchetti ufficiale di Python. Permette di installare, aggiornare, rimuovere e gestire pacchetti (librerie, moduli) Python provenienti dal Python Package Index (PyPI) e da altre fonti.

\subsection*{Cos'è pip}
\begin{itemize}
    \item \textbf{pip} sta per "Pip Installs Packages" o "Pip Installs Python".
    \item È incluso di default in Python dalla versione 3.4+.
    \item Gestisce l'installazione di pacchetti da PyPI (\url{https://pypi.org/}), repository privati, file locali, URL, ecc.
    \item Permette di gestire le dipendenze di progetto.
\end{itemize}

\subsection*{Installazione e aggiornamento di pip}
\begin{itemize}
    \item \textbf{Verifica se pip è installato:}
    \begin{lstlisting}
python -m pip --version
pip --version
    \end{lstlisting}
    \item \textbf{Aggiornamento di pip:}
    \begin{lstlisting}
python -m pip install --upgrade pip
    \end{lstlisting}
    \item \textbf{Installazione manuale (se necessario):}
    Scarica \texttt{get-pip.py} da \url{https://bootstrap.pypa.io/get-pip.py} e lancia:
    \begin{lstlisting}
python get-pip.py
    \end{lstlisting}
\end{itemize}

\subsection*{Comandi principali di pip}
\begin{itemize}
    \item \texttt{pip install nome\_pacchetto}: installa un pacchetto
    \item \texttt{pip install nome==versione}: installa una versione specifica
    \item \texttt{pip install "nome>=1.0,<2.0"}: installa una versione compresa tra due limiti
    \item \texttt{pip install -U nome}: aggiorna un pacchetto (\texttt{-U} = \texttt{--upgrade})
    \item \texttt{pip uninstall nome}: disinstalla un pacchetto
    \item \texttt{pip show nome}: mostra informazioni su un pacchetto
    \item \texttt{pip list}: elenca tutti i pacchetti installati
    \item \texttt{pip freeze}: elenca i pacchetti installati in formato \texttt{requirements.txt}
    \item \texttt{pip search parola}: cerca pacchetti su PyPI (\texttt{search} è deprecato)
    \item \texttt{pip check}: verifica conflitti tra dipendenze
\end{itemize}

\subsection*{Installazione da file, URL e repository}
\begin{itemize}
    \item \texttt{pip install ./pacchetto.whl}: da file wheel locale
    \item \texttt{pip install ./cartella/}: da directory locale con \texttt{setup.py}
    \item \texttt{pip install https://url/del/pacchetto.tar.gz}: da URL
    \item \texttt{pip install git+https://github.com/utente/repo.git}: da repository Git
\end{itemize}

\subsection*{Gestione delle dipendenze}
\begin{itemize}
    \item \texttt{pip install -r requirements.txt}: installa tutti i pacchetti elencati in un file
    \item \texttt{pip freeze > requirements.txt}: salva l'elenco dei pacchetti installati
\end{itemize}

\subsection*{Virtual environment e pip}
\begin{itemize}
    \item È buona pratica usare ambienti virtuali (\texttt{venv}, \texttt{virtualenv}) per isolare le dipendenze di progetto.
    \item Quando attivi un ambiente virtuale, \texttt{pip} installa i pacchetti solo in quell'ambiente.
    \item \texttt{python -m venv nome\_env} crea un ambiente virtuale.
\end{itemize}

\subsection*{Opzioni utili di pip}
\begin{itemize}
    \item \texttt{--user}: installa il pacchetto solo per l'utente corrente
    \item \texttt{--upgrade}: aggiorna il pacchetto all'ultima versione
    \item \texttt{--force-reinstall}: reinstalla anche se già presente
    \item \texttt{--no-deps}: non installa le dipendenze
    \item \texttt{--pre}: include versioni pre-release
    \item \texttt{--proxy}: usa un proxy per la connessione
    \item \texttt{--trusted-host}: aggiunge host fidati (utile con proxy/firewall)
\end{itemize}

\subsection*{Configurazione di pip}
\begin{itemize}
    \item File di configurazione: \texttt{pip.ini} (Windows), \texttt{.pip/pip.conf} (Linux/Mac)
    \item Puoi configurare repository alternativi, proxy, opzioni di default, ecc.
\end{itemize}

\subsection*{Installazione di pacchetti da repository privati}
\begin{lstlisting}
pip install --index-url https://mio.repo/simple nome
pip install --extra-index-url https://altro.repo/simple nome
\end{lstlisting}

\subsection*{Disinstallazione di pacchetti}
\begin{lstlisting}
pip uninstall nome_pacchetto
\end{lstlisting}

\subsection*{Aggiornamento di tutti i pacchetti}
Non esiste un comando unico, ma puoi usare:
\begin{lstlisting}
pip list --outdated
pip install --upgrade nome_pacchetto
\end{lstlisting}
Oppure uno script per aggiornare tutto:
\begin{lstlisting}
pip list --outdated --format=freeze |
    grep -v '^\-e' |
    cut -d = -f 1 |
    xargs -n1 pip install -U
\end{lstlisting}

\subsection*{Installazione di pacchetti in modalità "editable"}
\begin{lstlisting}
pip install -e ./mio_pacchetto/
\end{lstlisting}
Utile per lo sviluppo di pacchetti locali.

\subsection*{Cache di pip}
\begin{itemize}
    \item pip mantiene una cache dei pacchetti scaricati per velocizzare le installazioni successive.
    \item Puoi svuotare la cache con \texttt{pip cache purge}.
\end{itemize}

\subsection*{Problemi comuni e soluzioni}
\begin{itemize}
    \item \textbf{Permessi}: usa \texttt{--user} o esegui come amministratore/root se necessario.
    \item \textbf{Proxy/firewall}: configura \texttt{--proxy} o \texttt{--trusted-host}.
    \item \textbf{Versioni multiple di Python}: usa \texttt{python3 -m pip} o \texttt{python -m pip} per evitare conflitti.
    \item \textbf{Conflitti di dipendenze}: usa \texttt{pip check} per individuarli.
\end{itemize}

\subsection*{pip e PyPI}
\begin{itemize}
    \item PyPI (\url{https://pypi.org/}) è il repository ufficiale di pacchetti Python.
    \item Puoi pubblicare i tuoi pacchetti su PyPI usando \texttt{twine}.
\end{itemize}

\subsection*{pipx}
\begin{itemize}
    \item \texttt{pipx} è uno strumento per installare ed eseguire applicazioni Python in ambienti isolati.
    \item Utile per tool da linea di comando.
\end{itemize}

\subsection*{pipdeptree}
\begin{itemize}
    \item \texttt{pipdeptree} mostra la struttura delle dipendenze dei pacchetti installati.
    \item Installa con \texttt{pip install pipdeptree}.
\end{itemize}

\subsection*{pip e sicurezza}
\begin{itemize}
    \item Installa pacchetti solo da fonti affidabili.
    \item Controlla sempre le dipendenze e le versioni.
    \item Usa ambienti virtuali per evitare conflitti e rischi.
\end{itemize}

\subsection*{pip e requirements.txt}
\begin{itemize}
    \item \texttt{requirements.txt} è il file standard per elencare le dipendenze di un progetto.
    \item Puoi specificare versioni, intervalli, URL, riferimenti a repository.
    \item Esempio:
\begin{lstlisting}
requests>=2.25,<3.0
numpy==1.24.0
git+https://github.com/utente/repo.git
    \end{lstlisting}
\end{itemize}

\subsection*{pip e wheel}
\begin{itemize}
    \item \texttt{wheel} è il formato binario standard per la distribuzione di pacchetti Python.
    \item pip preferisce installare da wheel se disponibile (più veloce).
    \item Puoi creare un wheel con \texttt{python setup.py bdist\_wheel}.
\end{itemize}

\subsection*{pip e compatibilità}
\begin{itemize}
    \item pip funziona sia con Python 2 che con Python 3 (ma Python 2 è deprecato).
    \item Alcuni pacchetti potrebbero non essere compatibili con tutte le versioni di Python.
\end{itemize}

\subsection*{pip e documentazione}
\begin{itemize}
    \item Documentazione ufficiale: \url{https://pip.pypa.io/}
    \item Lista completa dei comandi: \texttt{pip --help}
    \item Per ogni comando: \texttt{pip <comando> --help}
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Installare una libreria
pip install requests

# Aggiornare una libreria
pip install --upgrade numpy

# Disinstallare una libreria
pip uninstall pandas

# Installare tutte le dipendenze di un progetto
pip install -r requirements.txt

# Salvare tutte le dipendenze in un file
pip freeze > requirements.txt

# Mostrare informazioni su un pacchetto
pip show flask

# Elencare tutti i pacchetti installati
pip list

# Verificare conflitti tra dipendenze
pip check
\end{lstlisting}

\subsection*{Conclusioni}
\texttt{pip} è uno strumento fondamentale per la gestione delle dipendenze e dei pacchetti in Python. Permette di installare, aggiornare, rimuovere e gestire librerie in modo semplice e potente, facilitando lo sviluppo, la distribuzione e la manutenzione dei progetti Python. La conoscenza approfondita di pip e delle sue funzionalità è essenziale per ogni sviluppatore Python moderno.

\section{Try except}
Il costrutto \texttt{try-except} in Python serve per la gestione delle eccezioni, ovvero per intercettare e gestire errori che si verificano durante l'esecuzione del programma senza interrompere il flusso del codice. È uno strumento fondamentale per scrivere codice robusto, sicuro e professionale.

\subsection*{Cos'è un'eccezione?}
Un'eccezione è un evento anomalo (errore) che si verifica durante l'esecuzione di un programma e che interrompe il normale flusso delle istruzioni. In Python, le eccezioni sono oggetti che rappresentano errori di vario tipo (es. divisione per zero, file non trovato, indice fuori range, ecc.).

\subsection*{Sintassi base di try-except}
\begin{lstlisting}
try:
    # blocco di codice che potrebbe generare un'eccezione
    x = 1 / 0
except ZeroDivisionError:
    # blocco eseguito se si verifica l'eccezione specificata
    print("Divisione per zero!")
\end{lstlisting}

\textbf{Funzionamento:}
\begin{itemize}
    \item Il codice nel blocco \texttt{try} viene eseguito normalmente.
    \item Se si verifica un'eccezione, l'esecuzione passa immediatamente al blocco \texttt{except} corrispondente.
    \item Se nessuna eccezione si verifica, il blocco \texttt{except} viene saltato.
    \item Se l'eccezione non viene gestita, il programma si interrompe e viene mostrato un traceback.
\end{itemize}

\subsection*{Gestione di più eccezioni}
Puoi gestire diversi tipi di eccezioni con più blocchi \texttt{except}:
\begin{lstlisting}
try:
    # codice
except ValueError:
    print("Valore non valido")
except ZeroDivisionError:
    print("Divisione per zero")
except Exception as e:
    print("Errore generico:", e)
\end{lstlisting}

\subsection*{Gestione multipla in un solo except}
Puoi gestire più tipi di eccezioni con una sola istruzione \texttt{except} usando una tupla:
\begin{lstlisting}
try:
    # codice
except (ValueError, TypeError):
    print("Errore di valore o di tipo")
\end{lstlisting}

\subsection*{Ottenere dettagli sull'eccezione}
Puoi accedere all'oggetto eccezione usando \texttt{as}:
\begin{lstlisting}
try:
    x = int("abc")
except ValueError as e:
    print("Errore:", e)
\end{lstlisting}

\subsection*{Blocco else}
Il blocco \texttt{else} viene eseguito solo se nessuna eccezione si è verificata nel blocco \texttt{try}:
\begin{lstlisting}
try:
    x = 10 / 2
except ZeroDivisionError:
    print("Divisione per zero")
else:
    print("Nessuna eccezione, risultato:", x)
\end{lstlisting}

\subsection*{Blocco finally}
Il blocco \texttt{finally} viene sempre eseguito, sia che si verifichi un'eccezione sia che non si verifichi:
\begin{lstlisting}
try:
    f = open("file.txt")
except FileNotFoundError:
    print("File non trovato")
else:
    print("File aperto correttamente")
finally:
    print("Operazione terminata")
\end{lstlisting}
Il \texttt{finally} è utile per rilasciare risorse (file, connessioni, ecc.).

\subsection*{Eccezioni annidate}
Puoi annidare blocchi \texttt{try-except}:
\begin{lstlisting}
try:
    try:
        x = int(input("Numero: "))
        y = 10 / x
    except ValueError:
        print("Non e' un numero")
except ZeroDivisionError:
    print("Divisione per zero")
\end{lstlisting}

\subsection*{Rilanciare un'eccezione}
Puoi rilanciare un'eccezione con \texttt{raise}:
\begin{lstlisting}
try:
    x = 1 / 0
except ZeroDivisionError:
    print("Errore, rilancio l'eccezione")
    raise
\end{lstlisting}

\subsection*{Sollevare eccezioni personalizzate}
Puoi sollevare un'eccezione con \texttt{raise}:
\begin{lstlisting}
def dividi(a, b):
    if b == 0:
        raise ValueError("Il divisore non puo' essere zero")
    return a / b
\end{lstlisting}

\subsection*{Definire eccezioni personalizzate}
Puoi creare le tue eccezioni ereditando da \texttt{Exception}:
\begin{lstlisting}
class ErrorePersonalizzato(Exception):
    pass

try:
    raise ErrorePersonalizzato("Messaggio di errore")
except ErrorePersonalizzato as e:
    print("Eccezione personalizzata:", e)
\end{lstlisting}

\subsection*{Gerarchia delle eccezioni}
Tutte le eccezioni derivano dalla classe base \texttt{BaseException}, ma normalmente si eredita da \texttt{Exception}. Alcune eccezioni comuni:
\begin{itemize}
    \item \texttt{Exception}: base per tutte le eccezioni standard
    \item \texttt{ValueError}, \texttt{TypeError}, \texttt{IndexError}, \texttt{KeyError}, \texttt{ZeroDivisionError}, \texttt{FileNotFoundError}, ecc.
    \item \texttt{KeyboardInterrupt}, \texttt{SystemExit}: derivano da \texttt{BaseException}, non vanno normalmente intercettate
\end{itemize}

\subsection*{Best practice}
\begin{itemize}
    \item Gestisci solo le eccezioni che puoi realmente trattare.
    \item Non usare \texttt{except:} senza specificare il tipo (rischi di nascondere errori gravi).
    \item Usa \texttt{except Exception:} per intercettare tutte le eccezioni standard, ma solo se necessario.
    \item Usa il blocco \texttt{finally} per chiudere file, connessioni, ecc.
    \item Documenta le eccezioni che una funzione può sollevare.
    \item Preferisci sollevare eccezioni specifiche e informative.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Lettura sicura di un file
try:
    with open("dati.txt") as f:
        dati = f.read()
except FileNotFoundError:
    print("File non trovato")
except Exception as e:
    print("Errore generico:", e)
else:
    print("File letto correttamente")
finally:
    print("Operazione completata")

# Input numerico sicuro
while True:
    try:
        x = int(input("Inserisci un numero: "))
        break
    except ValueError:
        print("Devi inserire un numero intero!")
\end{lstlisting}

\subsection*{Eccezioni e funzioni built-in}
Molte funzioni Python sollevano eccezioni in caso di errore (es. \texttt{int()}, \texttt{open()}, \texttt{list.index()}, ecc.).

\subsection*{Eccezioni e traceback}
Quando un'eccezione non viene gestita, Python stampa un traceback che mostra la sequenza delle chiamate che hanno portato all'errore.

\subsection*{Modulo traceback}
Per gestire e stampare manualmente il traceback:
\begin{lstlisting}
import traceback

try:
    1 / 0
except Exception:
    traceback.print_exc()
\end{lstlisting}

\subsection*{Eccezioni e context manager}
I context manager (\texttt{with}) gestiscono automaticamente le eccezioni e rilasciano le risorse anche in caso di errore.

\subsection*{Eccezioni e performance}
Lanciare e gestire eccezioni è più lento rispetto al normale flusso di codice: usale per gestire errori, non per il controllo di flusso ordinario.

\subsection*{Eccezioni e documentazione}
Documenta sempre le eccezioni che una funzione può sollevare, soprattutto se sono personalizzate.

\subsection*{Conclusioni}
La gestione delle eccezioni con \texttt{try-except} è fondamentale per scrivere codice Python robusto, sicuro e professionale. Permette di gestire gli errori in modo controllato, migliorare l'esperienza utente e prevenire crash inaspettati. La conoscenza approfondita di questo costrutto e delle best practice è essenziale per ogni sviluppatore Python.

\section{Input Dati}
La funzione \textbf{input} è una funzione built-in fondamentale per acquisire dati dall'utente tramite la tastiera. Permette di leggere stringhe inserite dall'utente durante l'esecuzione del programma. Di seguito una panoramica completa sull'input dei dati in Python.

\subsection*{Funzione \texttt{input()}}
La funzione \texttt{input()} legge una riga di testo dalla tastiera e la restituisce come stringa (\texttt{str}).

\begin{lstlisting}
nome = input("Come ti chiami? ")
print("Ciao,", nome)
\end{lstlisting}

\textbf{Nota:} Il testo tra parentesi viene visualizzato come \textit{prompt} per l'utente.

\subsection*{Tipo di ritorno}
\texttt{input()} restituisce sempre una stringa, anche se l'utente inserisce numeri.

\begin{lstlisting}
x = input("Inserisci un numero: ")
print(type(x))  # <class 'str'>
\end{lstlisting}

\subsection*{Conversione del tipo di dato (casting)}
Per ottenere un numero intero o float, bisogna convertire la stringa:

\begin{lstlisting}
x = int(input("Inserisci un intero: "))
y = float(input("Inserisci un numero decimale: "))
\end{lstlisting}

Se l'utente inserisce un valore non valido, viene sollevata un'eccezione (\texttt{ValueError}).

\subsection*{Gestione degli errori}
Per evitare crash, usa \texttt{try-except}:

\begin{lstlisting}
try:
    eta = int(input("Quanti anni hai? "))
except ValueError:
    print("Devi inserire un numero intero!")
\end{lstlisting}

\subsection*{Input multiplo su una riga}
Puoi acquisire più valori separati da spazi e convertirli con \texttt{split()}:

\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
a, b = input("Inserisci due numeri separati da spazio: ").split()
a = int(a)
b = int(b)
\end{lstlisting}

Oppure in una sola riga:

\begin{lstlisting}
a, b = map(int, input("Due numeri: ").split())
\end{lstlisting}

\subsection*{Input di liste o sequenze}
Per acquisire una lista di numeri:

\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
numeri = list(map(int, input("Inserisci numeri separati da spazio: ").split()))
\end{lstlisting}

\subsection*{Input senza prompt}
Se non passi argomenti a \texttt{input()}, non viene mostrato alcun messaggio:

\begin{lstlisting}
x = input()
\end{lstlisting}

\subsection*{Input e spazi bianchi}
\texttt{input()} legge tutta la riga, inclusi spazi e caratteri speciali. Puoi usare \texttt{strip()} per rimuovere spazi iniziali/finali:

\begin{lstlisting}
nome = input("Nome: ").strip()
\end{lstlisting}

\subsection*{Input e caratteri speciali}
Tutto ciò che l'utente digita viene letto come stringa, inclusi caratteri speciali, lettere accentate, ecc.

\subsection*{Input e EOF}
Se l'utente invia un EOF (Ctrl+D su Linux/Mac, Ctrl+Z su Windows), viene sollevata un'eccezione \texttt{EOFError}.

\begin{lstlisting}
try:
    x = input()
except EOFError:
    print("Fine input")
\end{lstlisting}

\subsection*{Input in cicli}
Spesso si usa \texttt{input()} in un ciclo per acquisire più dati:

\begin{lstlisting}
while True:
    riga = input("Scrivi qualcosa (q per uscire): ")
    if riga == "q":
        break
    print("Hai scritto:", riga)
\end{lstlisting}

\subsection*{Input e Unicode}
\texttt{input()} supporta caratteri Unicode (accenti, simboli, ecc.), purché il terminale li supporti.

\subsection*{Input e Python 2 vs Python 3}
In Python 2 esistevano \texttt{input()} e \texttt{raw\_input()}. In Python 3 esiste solo \texttt{input()}, che si comporta come il vecchio \texttt{raw\_input()}.

\subsection*{Input da file (redirezione)}
Puoi simulare l'input da tastiera redirigendo un file:

\begin{verbatim}
python mio_script.py < dati.txt
\end{verbatim}

\subsection*{Input e automazione}
Per test automatici, puoi simulare l'input usando \texttt{unittest.mock} o passando dati tramite stdin.

\subsection*{Input e sicurezza}
Non fidarti mai ciecamente dell'input utente: valida e gestisci sempre i possibili errori.

\subsection*{Esempi pratici}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
# Input di una stringa
nome = input("Nome: ")

# Input di un intero con controllo
while True:
    try:
        eta = int(input("Eta': "))
        break
    except ValueError:
        print("Inserisci un numero valido!")

# Input di una lista di numeri
numeri = list(map(int, input("Numeri separati da spazio: ").split()))
\end{lstlisting}

\subsection*{Conclusioni}
La funzione \texttt{input()} è il metodo standard per acquisire dati dall'utente in Python. È semplice, potente e flessibile, ma richiede attenzione nella conversione dei tipi e nella gestione degli errori. Una corretta gestione dell'input è fondamentale per scrivere programmi interattivi, robusti e user-friendly.

\section{Formattazione stringhe}
La \textbf{formattazione delle stringhe} in Python è l'insieme delle tecniche che permettono di inserire valori variabili, numeri, date, oggetti e risultati di espressioni all'interno di una stringa, controllando anche l'aspetto (allineamento, numero di decimali, padding, ecc.). Esistono diversi metodi per formattare le stringhe in Python, ciascuno con caratteristiche e sintassi proprie.

\subsection*{1. Concatenazione con \texttt{+}}
Il metodo più semplice (ma meno flessibile) consiste nel concatenare stringhe e convertire manualmente i valori:
\begin{lstlisting}
nome = "Anna"
eta = 25
s = "Ciao, mi chiamo " + nome + " e ho " + str(eta) + " anni."
print(s)
\end{lstlisting}
\textbf{Limiti:} poco leggibile, non adatto a tipi non stringa, difficile da mantenere.

\subsection*{2. Operatore \texttt{\%} (vecchio stile, stile C)}
Permette di inserire valori in una stringa usando specificatori di formato simili al C:
\begin{lstlisting}
nome = "Luca"
eta = 30
s = "Ciao, mi chiamo %s e ho %d anni." % (nome, eta)
print(s)
\end{lstlisting}
\textbf{Specificatori principali:}
\begin{itemize}
    \item \texttt{\%s}: stringa
    \item \texttt{\%d}: intero
    \item \texttt{\%f}: float (decimale)
    \item \texttt{\%.2f}: float con 2 decimali
    \item \texttt{\%x}, \texttt{\%o}: esadecimale, ottale
\end{itemize}
\textbf{Limiti:} meno flessibile, deprecato nelle nuove versioni.

\subsection*{3. Metodo \texttt{str.format()}}
Metodo moderno e potente, permette di inserire valori tramite \texttt{\{\}} (placeholder):
\begin{lstlisting}
nome = "Giulia"
eta = 28
s = "Ciao, mi chiamo {} e ho {} anni.".format(nome, eta)
print(s)
\end{lstlisting}
\textbf{Placeholder numerati o nominati:}
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
s = "Ciao, mi chiamo {0} e ho {1} anni.".format(nome, eta)
s = "Ciao, mi chiamo {nome} e ho {anni} anni.".format(nome=nome, anni=eta)
\end{lstlisting}

\textbf{Formattazione avanzata:}
\begin{itemize}
    \item \verb|:d|, \verb|:f|, \verb|:.2f|, \verb|:x|, \verb|:>10|, \verb|:^10|, \verb|:<10| per tipo, decimali, padding, allineamento
    \item \verb|:0>5| padding con zeri a sinistra
    \item \verb|:,| separatore delle migliaia
\end{itemize}
\begin{lstlisting}
x = 1234.56789
print("{:.2f}".format(x))      # 1234.57
print("{:10.2f}".format(x))    # '   1234.57'
print("{:0>8.2f}".format(x))   # '01234.57'
print("{:,}".format(1000000))  # '1,000,000'
print("{:^10}".format("ciao")) # '   ciao   '
\end{lstlisting}

\textbf{Accesso a indici, attributi e dizionari:}
\begin{lstlisting}
persona = {"nome": "Anna", "eta": 22}
print("Nome: {0[nome]}, Eta: {0[eta]}".format(persona))
class P: pass
p = P(); p.nome = "Luca"
print("Nome: {0.nome}".format(p))
\end{lstlisting}

\subsection*{4. f-string (formatted string literals, da Python 3.6+)}
Il metodo più moderno, leggibile e potente. Anteponi una \texttt{f} alla stringa e inserisci espressioni tra \texttt{\{\}}:
\begin{lstlisting}
nome = "Marco"
eta = 35
s = f"Ciao, mi chiamo {nome} e ho {eta} anni."
print(s)
\end{lstlisting}
\textbf{Supporta espressioni arbitrarie:}
\begin{lstlisting}
print(f"Tra 5 anni avro' {eta + 5} anni.")
\end{lstlisting}
\textbf{Formattazione avanzata:}
\begin{lstlisting}
x = 3.14159
print(f"Valore: {x:.2f}")      # Valore: 3.14
print(f"{1000:,}")             # 1,000
print(f"{'ciao':^10}")         # '   ciao   '
\end{lstlisting}
\textbf{Accesso a dizionari, attributi, indici:}
\begin{lstlisting}
d = {"a": 1}
print(f"Valore: {d['a']}")
class P: pass
p = P(); p.x = 10
print(f"x={p.x}")
\end{lstlisting}

\subsection*{5. Template string (modulo \texttt{string})}
Per casi in cui serve sicurezza (es. input utente), usa \texttt{string.Template}:
\begin{lstlisting}
from string import Template
t = Template("Ciao, $nome!")
print(t.substitute(nome="Anna"))
\end{lstlisting}
\textbf{Limiti:} meno potente, ma più sicuro contro injection.

\subsection*{6. Specificatori di formato (mini-language)}
La mini-linguaggio di formattazione permette:
\begin{itemize}
    \item \textbf{Tipo}: \texttt{d} (intero), \texttt{f} (float), \texttt{s} (stringa), \texttt{x} (esadecimale), \texttt{o} (ottale), \texttt{b} (binario)
    \item \textbf{Decimali}: \texttt{:.2f} (2 decimali)
    \item \textbf{Allineamento}: \texttt{\textless} (sinistra), \texttt{\textgreater} (destra), \texttt{\textasciicircum} (centrato)
    \item \textbf{Larghezza}: \texttt{:10} (10 caratteri)
    \item \textbf{Padding}: \texttt{:0\textgreater5} (zeri a sinistra)
    \item \textbf{Segno}: \texttt{:+} (mostra sempre il segno)
    \item \textbf{Separatore migliaia}: \texttt{:,}
    \item \textbf{Percentuale}: \texttt{:.2\%}
\end{itemize}
\begin{lstlisting}
n = 1234.567
print(f"{n:10.2f}")    # '   1234.57'
print(f"{n:0>10.2f}")  # '0001234.57'
print(f"{n:+.1f}")     # '+1234.6'
print(f"{n:,.2f}")     # '1,234.57'
print(f"{0.123:.2%}")  # '12.30%'
\end{lstlisting}

\subsection*{7. Escape di parentesi graffe}
Per stampare una parentesi graffa in una stringa formattata, raddoppiala:
\begin{lstlisting}
print(f"{{Questo e' tra parentesi graffe}}")
\end{lstlisting}

\subsection*{8. Formattazione di date e orari}
Puoi formattare oggetti \texttt{datetime} direttamente:
\begin{lstlisting}
import datetime
dt = datetime.datetime(2024, 6, 1, 14, 30)
print(f"{dt:%d/%m/%Y %H:%M}")  # 01/06/2024 14:30
\end{lstlisting}

\subsection*{9. Formattazione di numeri complessi, binari, ottali, esadecimali}
\begin{lstlisting}
n = 255
print(f"{n:b}")  # binario: 11111111
print(f"{n:o}")  # ottale: 377
print(f"{n:x}")  # esadecimale: ff
\end{lstlisting}

\subsection*{10. Arrotondamento e notazione scientifica}
\begin{lstlisting}
x = 12345.6789
print(f"{x:.2e}")  # 1.23e+04
\end{lstlisting}

\subsection*{11. Formattazione con variabili dinamiche}
Puoi usare variabili per specificare la larghezza o i decimali:
\begin{lstlisting}
w = 8
d = 3
x = 1.23456
print(f"{x:{w}.{d}f}")  #  '   1.235'
\end{lstlisting}

\subsection*{12. Formattazione di oggetti personalizzati}
Puoi personalizzare la formattazione implementando il metodo \texttt{\_\_format\_\_} nella tua classe.

\subsection*{13. Formattazione multilinea}
Le f-string possono essere multilinea:
\begin{lstlisting}
nome = "Anna"
messaggio = f"""
Ciao {nome},
benvenuta!
"""
\end{lstlisting}

\subsection*{14. Formattazione e localizzazione}
Per formattare numeri secondo la localizzazione:
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
import locale
locale.setlocale(locale.LC_ALL, "it_IT.UTF-8")
n = 1234567.89
print(locale.format_string("%.2f", n, grouping=True))  # '1.234.567,89'
\end{lstlisting}

\subsection*{15. Formattazione e sicurezza}
Non usare mai input utente direttamente in f-string o \texttt{format()} se può contenere codice malevolo.

\subsection*{16. Riepilogo e best practice}
\begin{itemize}
    \item Preferisci le f-string (Python 3.6+) per leggibilità e potenza.
    \item Usa \texttt{str.format()} se devi supportare versioni precedenti.
    \item L'operatore \texttt{\%} è obsoleto, usalo solo per compatibilità.
    \item Per casi di sicurezza, usa \texttt{string.Template}.
    \item Sfrutta la mini-linguaggio di formattazione per controllare decimali, padding, allineamento, ecc.
    \item Documenta sempre il formato delle stringhe se usato in API o file.
\end{itemize}

\subsection*{17. Documentazione ufficiale}
\begin{itemize}
    \item \url{https://docs.python.org/3/library/string.html#format-string-syntax}
    \item \url{https://docs.python.org/3/reference/lexical_analysis.html#f-strings}
\end{itemize}

\subsection*{Conclusioni}
La formattazione delle stringhe è fondamentale per produrre output leggibile, generare report, log, messaggi per l'utente, serializzare dati e molto altro. La padronanza delle tecniche di formattazione rende il codice più chiaro, potente e professionale.

\section{Lavorare con i file}
Lavorare con i file in Python è una delle operazioni fondamentali per leggere, scrivere, modificare e gestire dati persistenti. Python offre un supporto completo per la gestione dei file tramite funzioni built-in e moduli della libreria standard. Di seguito una panoramica dettagliata su tutto ciò che riguarda la manipolazione dei file in Python.

\subsection*{Apertura di un file: \texttt{open()}}
La funzione built-in \texttt{open()} permette di aprire un file e restituire un oggetto file. La sintassi è:
\begin{lstlisting}
f = open("nomefile.txt", "modalita'", encoding="utf-8")
\end{lstlisting}
\textbf{Parametri principali:}
\begin{itemize}
    \item \texttt{file}: percorso del file da aprire (relativo o assoluto)
    \item \texttt{mode}: modalità di apertura (default: \texttt{"r"})
    \item \texttt{encoding}: codifica del file (consigliato: \texttt{"utf-8"} per testi)
\end{itemize}

\subsubsection*{Modalità di apertura}
\begin{itemize}
    \item \texttt{"r"}: lettura (default), errore se il file non esiste
    \item \texttt{"w"}: scrittura, crea il file o sovrascrive se esiste
    \item \texttt{"a"}: append, scrive in fondo al file (crea se non esiste)
    \item \texttt{"x"}: scrittura esclusiva, errore se il file esiste già
    \item \texttt{"b"}: modalità binaria (es. \texttt{"rb"}, \texttt{"wb"})
    \item \texttt{"t"}: modalità testo (default, es. \texttt{"rt"}, \texttt{"wt"})
    \item \texttt{"+"}: lettura e scrittura (es. \texttt{"r+"}, \texttt{"w+"}, \texttt{"a+"})
\end{itemize}

\subsection*{Chiusura del file: \texttt{close()}}
Dopo aver lavorato con un file, è importante chiuderlo per liberare risorse:
\begin{lstlisting}
f.close()
\end{lstlisting}
\textbf{Nota:} Se dimentichi di chiudere un file, potresti perdere dati o bloccare risorse.

\subsection*{Context manager: \texttt{with}}
Il modo migliore per lavorare con i file è usare il context manager (\texttt{with}), che chiude automaticamente il file anche in caso di errore:
\begin{lstlisting}
with open("file.txt", "r", encoding="utf-8") as f:
    dati = f.read()
# Qui il file e' gia' chiuso
\end{lstlisting}

\subsection*{Lettura di file di testo}
\begin{itemize}
    \item \texttt{f.read()}: legge tutto il contenuto come stringa
    \item \texttt{f.readline()}: legge una riga alla volta (incluso il carattere di newline)
    \item \texttt{f.readlines()}: restituisce una lista di tutte le righe
    \item Iterazione diretta: \texttt{for riga in f: ...}
\end{itemize}
\begin{lstlisting}
with open("file.txt", "r", encoding="utf-8") as f:
    contenuto = f.read()
    f.seek(0)  # Torna all'inizio
    prima_riga = f.readline()
    f.seek(0)
    tutte_le_righe = f.readlines()
    f.seek(0)
    for riga in f:
        print(riga.strip())
\end{lstlisting}

\subsection*{Scrittura di file di testo}
\begin{itemize}
    \item \texttt{f.write(stringa)}: scrive una stringa nel file
    \item \texttt{f.writelines(lista)}: scrive una lista di stringhe (non aggiunge newline automaticamente)
\end{itemize}
\begin{lstlisting}
with open("output.txt", "w", encoding="utf-8") as f:
    f.write("Ciao mondo!\n")
    f.writelines(["Prima riga\n", "Seconda riga\n"])
\end{lstlisting}

\subsection*{Aggiunta (append) a un file}
\begin{lstlisting}
with open("log.txt", "a", encoding="utf-8") as f:
    f.write("Nuova riga\n")
\end{lstlisting}

\subsection*{Lettura e scrittura di file binari}
Per file non di testo (immagini, audio, pdf, ecc.), usa la modalità binaria:
\begin{lstlisting}
with open("immagine.jpg", "rb") as f:
    dati = f.read()

with open("copia.jpg", "wb") as f:
    f.write(dati)
\end{lstlisting}

\subsection*{Gestione della posizione nel file}
\begin{itemize}
    \item \texttt{f.tell()}: restituisce la posizione corrente (in byte)
    \item \texttt{f.seek(offset, whence)}: sposta il cursore (0: inizio, 1: posizione attuale, 2: fine)
\end{itemize}
\begin{lstlisting}
with open("file.txt", "r", encoding="utf-8") as f:
    f.seek(5)
    print(f.read())
    f.seek(0)
    print(f.tell())  # 0
\end{lstlisting}

\subsection*{Gestione degli errori}
Lavorare con i file può generare eccezioni (\texttt{FileNotFoundError}, \texttt{IOError}, ecc.):
\begin{lstlisting}
try:
    with open("file.txt") as f:
        dati = f.read()
except FileNotFoundError:
    print("File non trovato")
except Exception as e:
    print("Errore:", e)
\end{lstlisting}

\subsection*{File temporanei}
Per creare file temporanei usa il modulo \texttt{tempfile}:
\begin{lstlisting}
import tempfile

with tempfile.NamedTemporaryFile(delete=False) as tmp:
    tmp.write(b"test")
    print(tmp.name)
\end{lstlisting}

\subsection*{File e percorsi}
Per lavorare con percorsi in modo portabile usa il modulo \texttt{os} o \texttt{pathlib}:
\begin{lstlisting}
import os
from pathlib import Path

# Verifica esistenza file
if os.path.exists("file.txt"):
    print("Esiste")

# Pathlib (moderno)
p = Path("file.txt")
if p.exists():
    print("Esiste")
\end{lstlisting}

\subsection*{Eliminare, rinominare, copiare file}
\begin{lstlisting}
import os
import shutil

os.remove("file.txt")           # elimina file
os.rename("vecchio.txt", "nuovo.txt")  # rinomina
shutil.copy("file1.txt", "file2.txt")  # copia file
shutil.move("file1.txt", "cartella/")  # sposta file
\end{lstlisting}

\subsection*{Lettura e scrittura di file CSV}
Per file CSV usa il modulo \texttt{csv}:
\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize, breaklines=true, frame=single]
import csv

# Lettura
with open("dati.csv", newline="", encoding="utf-8") as f:
    reader = csv.reader(f)
    for riga in reader:
        print(riga)

# Scrittura
with open("output.csv", "w", newline="", encoding="utf-8") as f:
    writer = csv.writer(f)
    writer.writerow(["nome", "eta"])
    writer.writerows([["Anna", 25], ["Luca", 30]])
\end{lstlisting}

\subsection*{Lettura e scrittura di file JSON}
Vedi sezione dedicata, ma in breve:
\begin{lstlisting}
import json

with open("dati.json", "w", encoding="utf-8") as f:
    json.dump({"a": 1}, f, indent=2)

with open("dati.json", "r", encoding="utf-8") as f:
    dati = json.load(f)
\end{lstlisting}

\subsection*{Lettura e scrittura di file XML}
Usa il modulo \texttt{xml.etree.ElementTree}:
\begin{lstlisting}
import xml.etree.ElementTree as ET

tree = ET.parse("file.xml")
root = tree.getroot()
for elem in root:
    print(elem.tag, elem.text)
\end{lstlisting}

\subsection*{File e codifica (encoding)}
Specifica sempre l'encoding per file di testo (consigliato: \texttt{"utf-8"}). Attenzione a file con codifiche diverse (es. \texttt{"latin-1"}, \texttt{"cp1252"}).

\subsection*{File e newline}
Su Windows, Linux e Mac i caratteri di newline sono diversi. Python gestisce automaticamente la conversione in modalità testo. Per controllare il comportamento, usa il parametro \texttt{newline} in \texttt{open()}.

\subsection*{File e bufferizzazione}
\texttt{open()} accetta il parametro \texttt{buffering} per controllare la bufferizzazione. Di solito non serve modificarlo.

\subsection*{File e oggetti StringIO/BytesIO}
Per simulare file in memoria (utile per test), usa \texttt{io.StringIO} (testo) o \texttt{io.BytesIO} (binario):
\begin{lstlisting}
from io import StringIO

f = StringIO()
f.write("test")
f.seek(0)
print(f.read())
\end{lstlisting}

\subsection*{File e directory}
Per lavorare con directory:
\begin{lstlisting}
import os
from pathlib import Path

os.mkdir("nuova_cartella")
os.listdir(".")  # lista file e cartelle

# Pathlib
p = Path(".")
for file in p.iterdir():
    print(file)
\end{lstlisting}

\subsection*{File e permessi}
Attenzione ai permessi di lettura/scrittura/esecuzione. Su sistemi Unix puoi usare \texttt{os.chmod()}.

\subsection*{File locking (blocco file)}
Python non offre un locking portabile nativo. Su Unix puoi usare \texttt{fcntl}, su Windows \texttt{msvcrt}. Per casi avanzati, usa librerie esterne.

\subsection*{File e grandi dimensioni}
Per file molto grandi, leggi e scrivi a blocchi (chunk) per evitare di caricare tutto in memoria:
\begin{lstlisting}
with open("grande.txt", "r", encoding="utf-8") as f:
    while True:
        blocco = f.read(1024)
        if not blocco:
            break
        # processa blocco
\end{lstlisting}

\subsection*{File e compressione}
Per file compressi usa i moduli \texttt{gzip}, \texttt{bz2}, \texttt{zipfile}:
\begin{lstlisting}
import gzip

with gzip.open("file.txt.gz", "rt", encoding="utf-8") as f:
    dati = f.read()
\end{lstlisting}

\subsection*{File e best practice}
\begin{itemize}
    \item Usa sempre il context manager (\texttt{with}) per evitare di dimenticare la chiusura del file.
    \item Gestisci le eccezioni per evitare crash in caso di file mancanti o permessi insufficienti.
    \item Specifica sempre l'encoding per file di testo.
    \item Non leggere mai file enormi tutti in memoria: usa la lettura a blocchi o riga per riga.
    \item Per dati strutturati (CSV, JSON, XML), usa i moduli dedicati.
    \item Per test, usa \texttt{StringIO}/\texttt{BytesIO} per simulare file in memoria.
\end{itemize}

\subsection*{Esempi pratici}
\begin{lstlisting}
# Copiare un file di testo riga per riga
with open("input.txt", "r", encoding="utf-8") as fin, \
     open("output.txt", "w", encoding="utf-8") as fout:
    for riga in fin:
        fout.write(riga)

# Leggere solo le prime 10 righe di un file
with open("file.txt", "r", encoding="utf-8") as f:
    for i, riga in enumerate(f):
        if i >= 10:
            break
        print(riga.strip())
\end{lstlisting}

\subsection*{Documentazione ufficiale}
\begin{itemize}
    \item \url{https://docs.python.org/3/library/functions.html#open}
    \item \url{https://docs.python.org/3/library/io.html}
    \item \url{https://docs.python.org/3/library/os.html}
    \item \url{https://docs.python.org/3/library/pathlib.html}
\end{itemize}

\subsection*{Conclusioni}
La gestione dei file in Python è semplice, potente e flessibile. Conoscere tutte le modalità di apertura, le tecniche di lettura e scrittura, la gestione degli errori, i moduli per dati strutturati e le best practice è fondamentale per scrivere programmi robusti, efficienti e portabili.

\section{Gestione degli ambienti virtuali}
La \textbf{gestione degli ambienti virtuali} in Python è fondamentale per isolare le dipendenze di progetto, evitare conflitti tra librerie e mantenere un ambiente di sviluppo pulito e riproducibile. Un ambiente virtuale è una directory che contiene una copia isolata dell'interprete Python, delle librerie e degli script installati tramite \texttt{pip}.

\subsection*{Perché usare ambienti virtuali?}
\begin{itemize}
    \item Isolano le dipendenze di ciascun progetto.
    \item Permettono di lavorare con versioni diverse delle stesse librerie su progetti diversi.
    \item Evitano conflitti con i pacchetti installati globalmente.
    \item Facilitano la riproducibilità e la condivisione del progetto (requirements.txt).
    \item Consentono di testare codice con versioni diverse di Python/librerie.
\end{itemize}

\subsection*{Strumenti principali per ambienti virtuali}
\begin{itemize}
    \item \texttt{venv}: modulo standard da Python 3.3+.
    \item \texttt{virtualenv}: libreria esterna, compatibile anche con Python 2.
    \item \texttt{pipenv}: gestore di ambienti e dipendenze (combina pip e virtualenv).
    \item \texttt{poetry}: gestore moderno per ambienti, dipendenze e packaging.
    \item \texttt{conda}: gestore di ambienti e pacchetti per Python e altri linguaggi (Anaconda/Miniconda).
\end{itemize}

\subsection*{Creazione di un ambiente virtuale con venv (standard)}
\begin{lstlisting}
python -m venv nome_ambiente
\end{lstlisting}
\textbf{Nota:} Sostituisci \texttt{python} con \texttt{python3} se necessario.

\subsection*{Attivazione dell'ambiente virtuale}
\begin{itemize}
    \item \textbf{Windows:}
    \begin{lstlisting}
nome_ambiente\Scripts\activate
    \end{lstlisting}
    \item \textbf{Linux/Mac:}
    \begin{lstlisting}
source nome_ambiente/bin/activate
    \end{lstlisting}
\end{itemize}
Dopo l'attivazione, il prompt mostra il nome dell'ambiente.

\subsection*{Disattivazione dell'ambiente virtuale}
\begin{lstlisting}
deactivate
\end{lstlisting}

\subsection*{Installazione di pacchetti nell'ambiente virtuale}
Dopo l'attivazione, usa \texttt{pip} normalmente:
\begin{lstlisting}
pip install nome_pacchetto
\end{lstlisting}
I pacchetti saranno installati solo nell'ambiente attivo.

\subsection*{Eliminazione di un ambiente virtuale}
Basta cancellare la cartella dell'ambiente:
\begin{lstlisting}
rm -rf nome_ambiente
\end{lstlisting}

\subsection*{Verifica dell'ambiente attivo}
\begin{lstlisting}
which python      # Linux/Mac
where python      # Windows
\end{lstlisting}
Il percorso deve puntare all'interno della cartella dell'ambiente.

\subsection*{Gestione delle dipendenze}
\begin{itemize}
    \item \texttt{pip freeze > requirements.txt}: salva le dipendenze.
    \item \texttt{pip install -r requirements.txt}: installa le dipendenze.
\end{itemize}

\subsection*{Uso di virtualenv (alternativa a venv)}
\begin{lstlisting}
pip install virtualenv
virtualenv nome_ambiente
# Attivazione come per venv
\end{lstlisting}
\texttt{virtualenv} offre più opzioni e compatibilità con Python 2.

\subsection*{Uso di pipenv}
\begin{lstlisting}
pip install pipenv
pipenv install nome_pacchetto
pipenv shell
\end{lstlisting}
\texttt{Pipenv} crea e gestisce automaticamente l'ambiente virtuale e i file \texttt{Pipfile}/\texttt{Pipfile.lock}.

\subsection*{Uso di poetry}
\begin{lstlisting}
pip install poetry
poetry new mio_progetto
cd mio_progetto
poetry add nome_pacchetto
poetry shell
\end{lstlisting}
\texttt{Poetry} gestisce ambienti, dipendenze e packaging tramite \texttt{pyproject.toml}.

\subsection*{Uso di conda (Anaconda/Miniconda)}
\begin{lstlisting}
conda create -n mio_ambiente python=3.11
conda activate mio_ambiente
conda install nome_pacchetto
\end{lstlisting}
\texttt{Conda} gestisce ambienti e pacchetti (anche non Python).

\subsection*{Ambienti virtuali e IDE}
La maggior parte degli IDE (PyCharm, VSCode, ecc.) rileva e permette di selezionare l'ambiente virtuale per il progetto.

\subsection*{Ambienti virtuali e versioni di Python}
Puoi creare ambienti virtuali con versioni diverse di Python, specificando il percorso dell'interprete:
\begin{lstlisting}
python3.10 -m venv venv310
\end{lstlisting}

\subsection*{Ambienti virtuali e progetti multipli}
Ogni progetto dovrebbe avere il proprio ambiente virtuale, tipicamente nella cartella \texttt{venv/} o \texttt{.venv/}.

\subsection*{Ambienti virtuali e repository}
\begin{itemize}
    \item Non includere la cartella dell'ambiente virtuale nel controllo versione (aggiungi \texttt{venv/} a \texttt{.gitignore}).
    \item Condividi solo \texttt{requirements.txt}, \texttt{Pipfile.lock} o \texttt{pyproject.toml}.
\end{itemize}

\subsection*{Ambienti virtuali e script di attivazione}
Puoi automatizzare l'attivazione con script o configurazioni IDE.

\subsection*{Ambienti virtuali e Jupyter Notebook}
Per usare un ambiente virtuale in Jupyter:
\begin{lstlisting}
pip install ipykernel
python -m ipykernel install --user --name nome_ambiente
\end{lstlisting}
Poi seleziona il kernel corrispondente in Jupyter.

\subsection*{Ambienti virtuali e sicurezza}
\begin{itemize}
    \item Installa pacchetti solo da fonti affidabili.
    \item Aggiorna regolarmente le dipendenze.
    \item Usa ambienti virtuali per evitare conflitti e rischi di sicurezza.
\end{itemize}

\subsection*{Ambienti virtuali e automazione}
Per automatizzare la creazione e gestione degli ambienti, puoi usare \texttt{Makefile}, \texttt{tox}, \texttt{nox}, script shell, ecc.

\subsection*{Ambienti virtuali e path}
L'attivazione modifica le variabili d'ambiente (\texttt{PATH}, \texttt{VIRTUAL\_ENV}) per puntare all'ambiente attivo.

\subsection*{Ambienti virtuali e limitazioni}
\begin{itemize}
    \item Non isolano le variabili d'ambiente di sistema.
    \item Non isolano processi o file di configurazione esterni.
    \item Non sono adatti per deployment in produzione (usa container, Docker, ecc.).
\end{itemize}

\subsection*{Best practice}
\begin{itemize}
    \item Crea sempre un ambiente virtuale per ogni progetto.
    \item Non committare la cartella dell'ambiente.
    \item Usa file di dipendenze (\texttt{requirements.txt}, \texttt{Pipfile.lock}, \texttt{pyproject.toml}).
    \item Documenta come creare/attivare l'ambiente nel README.
    \item Aggiorna e verifica regolarmente le dipendenze.
\end{itemize}

\subsection*{Documentazione ufficiale}
\begin{itemize}
    \item \url{https://docs.python.org/3/library/venv.html}
    \item \url{https://virtualenv.pypa.io/}
    \item \url{https://pipenv.pypa.io/}
    \item \url{https://python-poetry.org/}
    \item \url{https://docs.conda.io/}
\end{itemize}

\subsection*{Conclusioni}
La gestione degli ambienti virtuali è una pratica essenziale nello sviluppo Python moderno. Permette di lavorare in modo isolato, sicuro e riproducibile, facilitando la collaborazione e la distribuzione dei progetti. La padronanza degli strumenti per la creazione, attivazione e gestione degli ambienti virtuali è fondamentale per ogni sviluppatore Python.

\section{Debugging e gestione degli errori}
Il \textbf{debugging} e la \textbf{gestione degli errori} sono aspetti fondamentali dello sviluppo software. Permettono di individuare, comprendere e correggere i problemi nei programmi Python, migliorando la qualità, l'affidabilità e la manutenibilità del codice.

\subsection*{Cos'è il debugging?}
Il debugging è il processo di individuazione e correzione degli errori (bug) nel codice. Un bug può essere un errore di sintassi, logica, runtime o di comportamento inatteso.

\subsection*{Tipi di errori in Python}
\begin{itemize}
    \item \textbf{Errori di sintassi} (\textit{SyntaxError}): errori nella struttura del codice (parentesi mancanti, errori di indentazione, ecc.).
    \item \textbf{Errori di runtime} (\textit{Exception}): errori che si verificano durante l'esecuzione (divisione per zero, file non trovato, ecc.).
    \item \textbf{Errori logici}: il programma si esegue senza errori, ma il risultato non è quello atteso.
\end{itemize}

\subsection*{Strumenti di debugging in Python}
\begin{itemize}
    \item \textbf{Stampa di variabili}: uso di \texttt{print()} per visualizzare valori intermedi.
    \item \textbf{Traceback}: messaggio di errore che mostra la sequenza delle chiamate che hanno portato all'errore.
    \item \textbf{Debugger interattivo} (\texttt{pdb}): permette di eseguire il codice passo-passo, impostare breakpoint, ispezionare variabili.
    \item \textbf{Debugging negli IDE}: strumenti grafici integrati in PyCharm, VSCode, Thonny, ecc.
    \item \textbf{Logging}: registrazione di messaggi, errori e informazioni tramite il modulo \texttt{logging}.
    \item \textbf{Test automatici}: uso di \texttt{unittest}, \texttt{pytest}, ecc. per individuare regressioni e bug.
    \item \textbf{Profiling}: analisi delle prestazioni e individuazione di colli di bottiglia.
\end{itemize}

\subsection*{Uso di print() per il debugging}
Il metodo più semplice: inserire \texttt{print()} in punti strategici del codice per controllare valori e flusso di esecuzione.
\begin{lstlisting}
def somma(a, b):
    print(f"a={a}, b={b}")
    return a + b
\end{lstlisting}
\textbf{Limiti:} poco scalabile, va rimosso dal codice finale.

\subsection*{Traceback e messaggi di errore}
Quando si verifica un'eccezione non gestita, Python stampa un traceback che mostra:
\begin{itemize}
    \item Il tipo di errore (es. \texttt{ZeroDivisionError})
    \item Il messaggio di errore
    \item La sequenza delle chiamate (stack trace)
    \item Il file e la riga dove si è verificato l'errore
\end{itemize}
\textbf{Esempio:}
\begin{lstlisting}
Traceback (most recent call last):
  File "main.py", line 2, in <module>
    print(1 / 0)
ZeroDivisionError: division by zero
\end{lstlisting}

\subsection*{Il modulo pdb (Python Debugger)}
\texttt{pdb} è il debugger interattivo standard di Python.
\begin{itemize}
    \item \verb|import pdb; pdb.set_trace()|: inserisce un breakpoint nel codice.
    \item \verb|python -m pdb script.py|: esegue uno script in modalità debug.
\end{itemize}
\textbf{Comandi principali di pdb:}
\begin{itemize}
    \item \texttt{n} (\textit{next}): esegui la prossima riga
    \item \texttt{c} (\textit{continue}): continua fino al prossimo breakpoint
    \item \texttt{l} (\textit{list}): mostra il codice sorgente
    \item \texttt{b} (\textit{break}): imposta un breakpoint
    \item \texttt{p} (\textit{print}): stampa il valore di una variabile
    \item \texttt{q} (\textit{quit}): esci dal debugger
\end{itemize}
\textbf{Esempio:}
\begin{lstlisting}
import pdb

def dividi(a, b):
    pdb.set_trace()
    return a / b

dividi(10, 0)
\end{lstlisting}

\subsection*{Debugging negli IDE}
La maggior parte degli IDE offre strumenti di debugging grafici:
\begin{itemize}
    \item Breakpoint visivi
    \item Esecuzione passo-passo
    \item Ispezione delle variabili
    \item Stack trace interattivo
    \item Watch expressions e valutazione di espressioni
\end{itemize}
\textbf{Consigliato} per progetti complessi.

\subsection*{Il modulo logging}
\texttt{logging} permette di registrare messaggi di debug, info, warning, error e critical in modo configurabile (console, file, ecc.).
\begin{lstlisting}
import logging

logging.basicConfig(level=logging.DEBUG)
logging.debug("Messaggio di debug")
logging.info("Informazione")
logging.warning("Attenzione")
logging.error("Errore")
logging.critical("Critico")
\end{lstlisting}
\textbf{Vantaggi:} puoi filtrare i messaggi, salvarli su file, disattivarli in produzione.

\subsection*{Gestione delle eccezioni}
Vedi anche la sezione \texttt{try-except}. Gestire le eccezioni permette di:
\begin{itemize}
    \item Prevenire crash del programma
    \item Fornire messaggi di errore chiari all'utente
    \item Loggare errori per analisi successive
    \item Eseguire azioni di recupero o fallback
\end{itemize}
\textbf{Esempio:}
\begin{lstlisting}
try:
    x = int(input("Numero: "))
except ValueError as e:
    logging.error(f"Errore di conversione: {e}")
    print("Devi inserire un numero intero!")
\end{lstlisting}

\subsection*{Eccezioni personalizzate}
Puoi definire eccezioni specifiche per il tuo dominio applicativo:
\begin{lstlisting}
class ErroreApplicazione(Exception):
    pass

raise ErroreApplicazione("Errore specifico")
\end{lstlisting}

\subsection*{Modulo traceback}
Per stampare o salvare il traceback di un'eccezione:
\begin{lstlisting}
import traceback

try:
    1 / 0
except Exception:
    traceback.print_exc()
\end{lstlisting}

\subsection*{Test automatici e debugging}
Scrivere test automatici (\texttt{unittest}, \texttt{pytest}) aiuta a individuare bug prima che il codice vada in produzione. I test falliti forniscono informazioni utili per il debugging.

\subsection*{Profiling e performance}
Per individuare colli di bottiglia e ottimizzare il codice:
\begin{itemize}
    \item \texttt{cProfile}, \texttt{profile}: moduli per il profiling delle prestazioni
    \item \texttt{timeit}: misura il tempo di esecuzione di piccoli blocchi di codice
\end{itemize}

\subsection*{Altri strumenti utili}
\begin{itemize}
    \item \texttt{faulthandler}: stampa il traceback anche per errori fatali (es. segmentation fault)
    \item \texttt{warnings}: gestisce e controlla i warning (avvisi non fatali)
    \item \texttt{assert}: verifica condizioni durante lo sviluppo, solleva AssertionError se la condizione è falsa
\end{itemize}
\begin{lstlisting}
assert x > 0, "x deve essere positivo"
\end{lstlisting}

\subsection*{Debugging di codice concorrente}
Per il debugging di thread e processi multipli, usa strumenti come:
\begin{itemize}
    \item \texttt{threading.settrace()}, \texttt{multiprocessing.set\_start\_method()}
    \item Debugger avanzati: \texttt{pdb++}, \texttt{pydevd}, \texttt{remote-pdb}
\end{itemize}

\subsection*{Debugging remoto}
Puoi eseguire il debug di applicazioni remote (es. server, container) usando debugger remoti come \texttt{debugpy}, \texttt{pydevd}, \texttt{remote-pdb}.

\subsection*{Debugging di memory leak}
Per individuare perdite di memoria:
\begin{itemize}
    \item \texttt{gc}: modulo per la gestione del garbage collector
    \item \texttt{tracemalloc}: traccia l'allocazione della memoria
    \item Strumenti esterni: \texttt{objgraph}, \texttt{memory-profiler}, \texttt{heapy}
\end{itemize}
\begin{lstlisting}
import tracemalloc
tracemalloc.start()
# ... codice ...
print(tracemalloc.get_traced_memory())
\end{lstlisting}

\subsection*{Debugging di codice C/estensioni}
Per bug in moduli C o estensioni, usa strumenti come \texttt{gdb}, \texttt{valgrind}, o il supporto di \texttt{faulthandler}.

\subsection*{Debugging e best practice}
\begin{itemize}
    \item Scrivi codice semplice e leggibile.
    \item Usa nomi di variabili chiari.
    \item Commenta il codice complesso.
    \item Scrivi test automatici.
    \item Gestisci sempre le eccezioni.
    \item Usa il logging invece di print() in produzione.
    \item Rimuovi codice di debug prima di rilasciare.
    \item Documenta i bug noti e le soluzioni adottate.
\end{itemize}

\subsection*{Debugging e documentazione}
Consulta sempre la documentazione ufficiale e le risorse della community (Stack Overflow, GitHub Issues, ecc.) per soluzioni a problemi comuni.

\subsection*{Debugging e versionamento}
Usa un sistema di controllo versione (es. git) per poter tornare a versioni funzionanti del codice e isolare le modifiche che introducono bug.

\subsection*{Debugging e ambienti di test}
Esegui il codice in ambienti di test o staging prima di metterlo in produzione.

\subsection*{Debugging e Continuous Integration}
Integra strumenti di test e analisi statica (linting, type checking) nelle pipeline CI/CD per individuare bug automaticamente.

\subsection*{Risorse utili}
\begin{itemize}
    \item \url{https://docs.python.org/3/library/pdb.html}
    \item \url{https://docs.python.org/3/library/logging.html}
    \item \url{https://docs.python.org/3/library/traceback.html}
    \item \url{https://realpython.com/python-debugging-pdb/}
    \item \url{https://docs.python.org/3/library/unittest.html}
\end{itemize}

\subsection*{Conclusioni}
Il debugging e la gestione degli errori sono competenze essenziali per ogni sviluppatore Python. Saper individuare, analizzare e risolvere i bug, usare gli strumenti giusti e adottare le best practice permette di scrivere codice più robusto, affidabile e professionale.

\end{document}
